

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Runge–Kutta methods &#8212; Fundamentals of Numerical Computation</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" integrity="sha384-KA6wR/X5RY4zFAHpv/CnoG2UW1uogYfdnP67Uv7eULvTveboZJg0qUpmJZb5VqzN" crossorigin="anonymous">
    <link href="../_static/css/index.css" rel="stylesheet">
    <link rel="stylesheet" href="../_static/sphinx-book-theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
    <link rel="stylesheet" type="text/css" href="../_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="../_static/jupyter-sphinx.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/sphinx-book-theme.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/mystnb.js"></script>
    <script src="../_static/proof.js"></script>
    <script src="../_static/sphinx-book-theme.js"></script>
    <script >var togglebuttonSelector = '.toggle, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.18.0/dist/embed-amd.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"TeX": {"Macros": {"float": ["\\mathbb{F}"], "real": ["\\mathbb{R}"], "complex": ["\\mathbb{C}"], "nat": ["\\mathbb{N}"], "integer": ["\\mathbb{Z}"], "rmn{([^}]*)}{([^}]*)}": ["\\mathbb{R}^{#1 \\times #2}", 2], "dd{([^}]*)}{([^}]*)}": ["\\frac{d #1}{d #2}", 2], "ddd{([^}]*)}{([^}]*)}": ["\\frac{d^2 #1}{d #2^2}", 2], "pp{([^}]*)}{([^}]*)}": ["\\frac{\\partial #1}{\\partial #2}", 2], "ppp{([^}]*)}{([^}]*)}": ["\\frac{\\partial^2 #1}{\\partial #2^2}", 2], "ppdd{([^}]*)}{([^}]*)}{([^}]*)}": ["\\frac{\\partial^2 #1}{\\partial #2 \\partial #3}", 3], "norm{([^}]*)}": ["\\| #1 \\|", 1], "twonorm{([^}]*)}": ["\\| #1 \\|_2", 1], "onenorm{([^}]*)}": ["\\| #1 \\|_1", 1], "infnorm{([^}]*)}": ["\\| #1 \\|_\\infty", 1], "anynorm{([^}]*)}{([^}]*)}": ["\\| #1 \\|_#2", 2], "innerprod{([^}]*)}{([^}]*)}": ["\\langle #1,#2 \\rangle", 2], "pr{([^}]*)}": ["^{(#1)}", 1], "kron{([^}]*)}{([^}]*)}": ["#1 \\otimes #2", 2], "eye{([^}]*)}": ["\\mathbf{e}_#1", 1], "meye": ["\\mathbf{I}"], "Qhat": ["\\hat{\\mathbf{Q}}"], "Rhat": ["\\hat{\\mathbf{R}}"], "bfalpha": ["\\mathbf{alpha}"], "bfdelta": ["\\mathbf{delta}"], "bfzero": ["\\boldsymbol{0}"], "macheps": ["\\epsilon_\\text{mach}"], "fl": ["\\operatorname{fl}"], "diag": ["\\operatorname{diag}"], "ign": ["\\operatorname{sign}"], "Re": ["\\operatorname{Re}"], "Im": ["\\operatorname{Im}"], "ee": ["\\times 10^"], "lnorm": ["\\|"], "rnorm": ["\\|"], "floor": ["\\lfloor#1\\rfloor", 1]}}})</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Adaptive Runge–Kutta" href="adaptive.html" />
    <link rel="prev" title="Systems of differential equations" href="systems.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="docsearch:language" content="en">



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../index.html">
  
  <img src="../_static/logo.png" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">Fundamentals of Numerical Computation</h1>
  
</a>
</div>

<form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form>

<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  
  <ul class="nav sidenav_l1">
  <li class="">
    <a href="../frontmatter.html">Home</a>
  </li>
  <li class="">
    <a href="../intro/overview.html">Introduction</a>
  </li>
  <li class="">
    <a href="../linsys/overview.html">Square linear systems</a>
  </li>
  <li class="">
    <a href="../leastsq/overview.html">Overdetermined linear systems</a>
  </li>
  <li class="">
    <a href="../nonlineqn/overview.html">Roots of nonlinear equations</a>
  </li>
  <li class="">
    <a href="../localapprox/overview.html">Piecewise interpolation</a>
  </li>
  <li class="active">
    <a href="overview.html">Initial-value problems for ODEs</a>
  <ul class="nav sidenav_l2">
    <li class="">
      <a href="basics.html">Basics of IVPs</a>
    </li>
    <li class="">
      <a href="euler.html">Euler’s method</a>
    </li>
    <li class="">
      <a href="systems.html">Systems of differential equations</a>
    </li>
    <li class="active">
      <a href="">Runge–Kutta methods</a>
    </li>
    <li class="">
      <a href="adaptive.html">Adaptive Runge–Kutta</a>
    </li>
    <li class="">
      <a href="multistep.html">Multistep methods</a>
    </li>
    <li class="">
      <a href="implicit.html">Implementation of multistep methods</a>
    </li>
    <li class="">
      <a href="zerostability.html">Zero-stability of multistep methods</a>
    </li>
    <li class="">
      <a href="next.html">Next steps</a>
    </li>
  </ul>
  </li>
  <li class="">
    <a href="../appendix/linear-algebra.html">Review: Linear algebra</a>
  </li>
  <li class="">
    <a href="../appendix/demos.html">All demo notebooks</a>
  </li>
  <li class="">
    <a href="../refs.html">References</a>
  </li>
  <li class="">
    <a href="../genindex.html">Index</a>
  </li>
</ul>
</nav>

 <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse" data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu" aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation" title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        <div class="dropdown-buttons-trigger">
            <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i class="fas fa-download"></i></button>

            
            <div class="dropdown-buttons">
                <!-- ipynb file if we had a myst markdown file -->
                
                <!-- Download raw file -->
                <a class="dropdown-buttons" href="../_sources/ivp/rk.md"><button type="button" class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip" data-placement="left">.md</button></a>
                <!-- Download PDF via print -->
                <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF" onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
            </div>
            
        </div>

        <!-- Edit this page -->
        

        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="bottom" onclick="toggleFullScreen()" title="Fullscreen mode"><i class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->
        
    </div>
    <div class="d-none d-md-block col-md-2 bd-toc show">
<div class="tocsection onthispage pt-5 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="nav section-nav flex-column">
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#a-second-order-method" class="nav-link">A second-order method</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#implementation" class="nav-link">Implementation</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#more-runge-kutta-methods" class="nav-link">More Runge–Kutta methods</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#efficiency" class="nav-link">Efficiency</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#exercises" class="nav-link">Exercises</a>
        </li>
    
    </ul>
</nav>


    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="runge-kutta-methods">
<h1>Runge–Kutta methods<a class="headerlink" href="#runge-kutta-methods" title="Permalink to this headline">¶</a></h1>
<div class="margin sidebar" id="index-0">
<p class="sidebar-title"></p>
<p>RK methods boost the order of accuracy by evaluating the ODE function <span class="math notranslate nohighlight">\(f(t,u)\)</span> more than once per time step.</p>
</div>
<p>We come now to one of the major and most-used types of methods for initial-value problems: <a class="reference internal" href="overview.html#term-runge-kutta"><span class="xref std std-term">Runge–Kutta</span></a> (RK) methods.<a class="footnote-reference brackets" href="#rk" id="id1">1</a> They are one-step methods in the sense of <a class="reference internal" href="euler.html#equation-onestepode">(170)</a>, though they are not often written in that form. RK methods boost the accuracy past first order by evaluating the ODE function <span class="math notranslate nohighlight">\(f(t,u)\)</span> more than once per time step.</p>
<div class="section" id="a-second-order-method">
<h2>A second-order method<a class="headerlink" href="#a-second-order-method" title="Permalink to this headline">¶</a></h2>
<p>Consider a series expansion of the exact solution to <span class="math notranslate nohighlight">\(u'=f(t,u)\)</span>,</p>
<div class="math notranslate nohighlight" id="equation-taylor2">
<span class="eqno">(178)<a class="headerlink" href="#equation-taylor2" title="Permalink to this equation">¶</a></span>\[\hat{u}(t_{i+1}) = \hat{u}(t_i) + h \hat{u}'(t_i) + \frac{1}{2}h^2 \hat{u}''(t_i) + O(h^3) .\]</div>
<p>If we replace <span class="math notranslate nohighlight">\(\hat{u}'\)</span> by <span class="math notranslate nohighlight">\(f\)</span> and keep only the first two terms on the right-hand side, we would obtain the Euler method. To get more accuracy we will need to compute or estimate the third term too. Note that</p>
<div class="math notranslate nohighlight">
\[\hat{u}'' = f' = \frac{d f}{d t} = \frac{\partial f}{\partial t} + \frac{\partial f}{\partial u} \frac{d u}{d t} = f_t + f_u f,\]</div>
<p>where we have applied the multidimensional chain rule to the derivative, because both of the arguments to <span class="math notranslate nohighlight">\(f\)</span> depend on <span class="math notranslate nohighlight">\(t\)</span>. Using this expression in <a class="reference internal" href="#equation-taylor2">(178)</a>, we obtain</p>
<div class="math notranslate nohighlight" id="equation-rkexactexpand">
<span class="eqno">(179)<a class="headerlink" href="#equation-rkexactexpand" title="Permalink to this equation">¶</a></span>\[\begin{split}  \hat{u}(t_{i+1}) = \hat{u}(t_i) + h\left[f\bigl(t_i,\hat{u}(t_i)\bigr) +
    \frac{h}{2}f_t\bigl(t_i,\hat{u}(t_i)\bigr) +
    \frac{h}{2}f\bigl(t_i,\hat{u}(t_i)\bigr)\,f_u\bigl(t_i,\hat{u}(t_i)\bigr)\right] \\
  + O(h^3).\end{split}\]</div>
<p>We have no desire to calculate and then code those partial derivatives of <span class="math notranslate nohighlight">\(f\)</span> directly; an approximate approximation is called for. Observe that</p>
<div class="math notranslate nohighlight" id="equation-mvtaylor2">
<span class="eqno">(180)<a class="headerlink" href="#equation-mvtaylor2" title="Permalink to this equation">¶</a></span>\[  f\bigl(t_i+\alpha,\hat{u}(t_i)+\beta\bigr) = f\bigl(t_i,\hat{u}(t_i)\bigr) +
  \alpha f_t\bigl(t_i,\hat{u}(t_i)\bigr) + \beta f_u\bigl(t_i,\hat{u}(t_i)\bigr) +
  O\bigl(\alpha^2 + |\alpha\beta| + \beta^2\bigr).\]</div>
<p>Matching this expression to the term in brackets in <a class="reference internal" href="#equation-rkexactexpand">(179)</a>, it seems natural to select <span class="math notranslate nohighlight">\(\alpha = h/2\)</span> and <span class="math notranslate nohighlight">\(\beta = \frac{1}{2}hf\bigl(t_i,\hat{u}(t_i)\bigr)\)</span>. Doing so, we find</p>
<div class="math notranslate nohighlight">
\[  \hat{u}(t_{i+1}) = \hat{u}(t_i) + h\left[f\bigl(t_i+\alpha,\hat{u}(t_i)+\beta\bigr)\right] +
  O(h\alpha^2 + h|\alpha \beta| + h\beta^2 + h^3).\]</div>
<p>Truncating results in the one-step formula</p>
<div class="math notranslate nohighlight" id="equation-ie">
<span class="eqno">(181)<a class="headerlink" href="#equation-ie" title="Permalink to this equation">¶</a></span>\[{u}_{i+1} = u_i +  hf\left(t_i+\tfrac{1}{2}h,u_i+\tfrac{1}{2}h f(t_i,u_i)\right), 
\qquad i = 0,\ldots,n-1.\]</div>
<p>We call this the <strong>improved Euler</strong> method. Thanks to the definitions above of <span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span>, the omitted terms are of size</p>
<div class="math notranslate nohighlight">
\[  O(h\alpha^2 + h|\alpha \beta| + h\beta^2 + h^3) = O(h^3).\]</div>
<p>Therefore <span class="math notranslate nohighlight">\(h\tau_{i+1}=O(h^3)\)</span>, and the order of accuracy of improved Euler is two. We refer to it as <strong>IE2</strong>.</p>
</div>
<div class="section" id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h2>
<p>Runge–Kutta methods are called <strong>multistage</strong> methods. We can see why if we interpret <a class="reference internal" href="#equation-ie">(181)</a> from the inside out. In the first stage, the method takes an Euler half-step to time <span class="math notranslate nohighlight">\(t_i+h/2\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{split}
  k_1 &amp;= h f(t_i,u_i) \\
  v &amp;= u_i + \tfrac{1}{2}k_1.
\end{split}\end{split}\]</div>
<p>The second stage employs an Euler-style strategy over the whole time step, but using the value from the first stage to get the slope, rather than using <span class="math notranslate nohighlight">\(f(t_i,u_i)\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{split}
  k_2 &amp;= h f\left(t_i+\tfrac{1}{2}h,v\right)\\
  {u}_{i+1} &amp;= u_i + k_2.
\end{split}\end{split}\]</div>
<p>Our implementation of IE2 is shown in <a class="reference internal" href="#function-ie2"><span class="std std-ref">ie2</span></a>.</p>
<div class="proof proof-type-function" id="id2">
<span id="function-ie2"></span>
    <div class="proof-title">
        <span class="proof-type">Function 66</span>
        
            <span class="proof-title-name">(ie2)</span>
        
    </div><div class="proof-content">
<p><strong>Improved Euler method for an IVP.</strong></p>
<div class="highlight-julia notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="s">&quot;&quot;&quot;</span>
<span class="s">ie2(ivp,n)</span>

<span class="s">Apply the Improved Euler method to solve the given IVP using `n`</span>
<span class="s">time steps. Returns a vector of times and a vector of solution</span>
<span class="s">values.</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="k">function</span> <span class="n">ie2</span><span class="p">(</span><span class="n">ivp</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
    <span class="c"># Time discretization.</span>
    <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="o">=</span> <span class="n">ivp</span><span class="o">.</span><span class="n">tspan</span>
    <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="n">n</span>
    <span class="n">t</span> <span class="o">=</span> <span class="p">[</span> <span class="n">a</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">h</span> <span class="k">for</span> <span class="n">i</span> <span class="kp">in</span> <span class="mi">0</span><span class="o">:</span><span class="n">n</span> <span class="p">]</span>

    <span class="c"># Initialize output.</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">fill</span><span class="p">(</span><span class="n">float</span><span class="p">(</span><span class="n">ivp</span><span class="o">.</span><span class="n">u0</span><span class="p">),</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="c"># Time stepping.</span>
    <span class="k">for</span> <span class="n">i</span> <span class="kp">in</span> <span class="mi">1</span><span class="o">:</span><span class="n">n</span>
        <span class="n">uhalf</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">ivp</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">ivp</span><span class="o">.</span><span class="n">p</span><span class="p">,</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="o">*</span><span class="n">ivp</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="n">uhalf</span><span class="p">,</span><span class="n">ivp</span><span class="o">.</span><span class="n">p</span><span class="p">,</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
    <span class="k">end</span>
    <span class="k">return</span> <span class="n">t</span><span class="p">,</span><span class="n">u</span>
<span class="k">end</span>
</pre></div>
</td></tr></table></div>
</div></div></div>
<div class="section" id="more-runge-kutta-methods">
<h2>More Runge–Kutta methods<a class="headerlink" href="#more-runge-kutta-methods" title="Permalink to this headline">¶</a></h2>
<p>The idea of matching Taylor expansions can be generalized to higher orders of accuracy. To do so, however, we must introduce additional stages, each having free parameters so that more terms in the series may be matched. The amount of algebra grows rapidly in size and complexity, though there is a sophisticated theory for keeping track of it. We do not give the derivation details.</p>
<p>There are many known Runge–Kutta methods. We present a generic <span class="math notranslate nohighlight">\(s\)</span>-stage method in the form</p>
<div class="math notranslate nohighlight" id="equation-rk">
<span class="eqno">(182)<a class="headerlink" href="#equation-rk" title="Permalink to this equation">¶</a></span>\[\begin{split}  \begin{split}
    k_1 &amp;= h f(t_i,u_i)\\
    k_2 &amp;= h f(t_i+c_1h,u_i + a_{11}k_1)\\
    k_3 &amp;= h f(t_i+c_2h, u_i + a_{21}k_1 + a_{22}k_2)\\
    &amp;\vdots\\
    k_s &amp;= h f(t_i + c_{s-1}h, u_i + a_{s-1,1}k_1 + \cdots +
    a_{s-1,s-1}k_{s-1})\\
    \mathbf{u}_{i+1} &amp;= u_i + b_1k_1 + \cdots + b_s k_s
  \end{split}\end{split}\]</div>
<p>This recipe is completely determined by the number of stages <span class="math notranslate nohighlight">\(s\)</span> and the constants <span class="math notranslate nohighlight">\(a_{ij}\)</span>, <span class="math notranslate nohighlight">\(b_j\)</span>, and <span class="math notranslate nohighlight">\(c_i\)</span>.  Often an RK method is presented as just a table of these numbers, as in</p>
<div class="math notranslate nohighlight">
\[\begin{split}  \begin{array}{r|ccccc}
    0 &amp;  &amp;  &amp; &amp; &amp; \\
    c_1 &amp; a_{11} &amp; &amp; &amp;\\
    c_2 &amp; a_{21} &amp; a_{22} &amp; &amp; &amp;\\
    \vdots &amp; \vdots &amp; &amp; \ddots &amp; &amp;\\
    c_{s-1} &amp; a_{s-1,1} &amp; \cdots &amp; &amp; a_{s-1,s-1}&amp;\\[1mm] \hline
    \rule{0pt}{2.25ex}    &amp; b_1 &amp; b_2 &amp; \cdots &amp; b_{s-1} &amp; b_s
  \end{array}\end{split}\]</div>
<p>For example, IE2 is given by</p>
<div class="math notranslate nohighlight">
\[\begin{split}  \begin{array}{r|cc}
    \rule{0pt}{2.75ex}0 &amp;  &amp;  \\
    \rule{0pt}{2.75ex}\frac{1}{2} &amp; \frac{1}{2} &amp;\\[1mm] \hline
    \rule{0pt}{2.75ex}&amp; 0 &amp; 1
  \end{array}\end{split}\]</div>
<p>Here are two more 2-stage, second-order methods, <strong>modified Euler</strong> and <strong>Heun’s</strong>, respectively:</p>
<div class="math notranslate nohighlight">
\[\begin{split}  \begin{array}{r|cc}
    \rule{0pt}{2.75ex}0 &amp;  &amp;  \\
    \rule{0pt}{2.75ex}1 &amp; 1 &amp;\\[1mm] \hline
    \rule{0pt}{2.75ex}&amp; \frac{1}{2} &amp; \frac{1}{2}
  \end{array}
  \qquad \qquad
  \begin{array}{r|cc}
   \rule{0pt}{2.75ex} 0 &amp;  &amp;  \\
   \rule{0pt}{2.75ex} \frac{2}{3} &amp; \frac{2}{3} &amp;\\[1mm] \hline
   \rule{0pt}{2.75ex} &amp; \frac{1}{4} &amp; \frac{3}{4}
  \end{array}\end{split}\]</div>
<p>The most commonly used RK method, and perhaps the most popular IVP method of all, is the fourth-order one given by</p>
<div class="math notranslate nohighlight" id="equation-rk4">
<span class="eqno">(183)<a class="headerlink" href="#equation-rk4" title="Permalink to this equation">¶</a></span>\[\begin{split}  \begin{array}{r|cccc}
    \rule{0pt}{2.75ex}0 &amp;  &amp; &amp; &amp; \\
    \rule{0pt}{2.75ex}\frac{1}{2} &amp; \frac{1}{2} &amp; &amp; &amp;\\
    \rule{0pt}{2.75ex}\frac{1}{2} &amp; 0 &amp; \frac{1}{2} &amp; &amp;\\
    \rule{0pt}{2.75ex}1 &amp; 0 &amp; 0 &amp; 1\\[1mm] \hline
    \rule{0pt}{2.75ex}&amp; \frac{1}{6} &amp; \frac{1}{3} &amp; \frac{1}{3} &amp; \frac{1}{6}
  \end{array}\end{split}\]</div>
<p>This formula is often called “the” fourth-order RK method—even though there are others—and we shall refer to it as RK4.  Written out, the recipe is</p>
<div class="math notranslate nohighlight" id="equation-rk4def">
<span class="eqno">(184)<a class="headerlink" href="#equation-rk4def" title="Permalink to this equation">¶</a></span>\[\begin{split}  \begin{split}
    k_1 &amp;= hf(t_i,u_i), \\
    k_2 &amp;= hf(t_i+h/2,u_i+k_1/2),\\
    k_3 &amp;= hf(t_i+h/2,u_i+k_2/2),\\
    k_4 &amp;= hf(t_i+h,u_i+k_3),\\
    u_{i+1} &amp;= u_i + \frac{1}{6} k_1 + \frac{1}{3} k_2 + \frac{1}{3} k_3 + \frac{1}{6} k_4.
  \end{split}\end{split}\]</div>
<div class="demo sidebar">
<p class="sidebar-title">Demo</p>
<p><a class="reference internal" href="demos/rk-converge.html"><span class="doc">Convergence of RK methods</span></a></p>
</div>
<p>Our implementation is given in <a class="reference internal" href="#function-rk4"><span class="std std-ref">rk4</span></a>.</p>
<div class="proof proof-type-function" id="id3">
<span id="function-rk4"></span>
    <div class="proof-title">
        <span class="proof-type">Function 67</span>
        
            <span class="proof-title-name">(rk4)</span>
        
    </div><div class="proof-content">
<p><strong>Fourth-order Runge-Kutta for an IVP.</strong></p>
<div class="highlight-julia notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="s">&quot;&quot;&quot;</span>
<span class="s">rk4(ivp,n)</span>

<span class="s">Apply &quot;the&quot; Runge-Kutta 4th order method to solve the given IVP</span>
<span class="s">using `n` time steps. Returns a vector of times and a vector of</span>
<span class="s">solution values.</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="k">function</span> <span class="n">rk4</span><span class="p">(</span><span class="n">ivp</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
    <span class="c"># Time discretization.</span>
    <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="o">=</span> <span class="n">ivp</span><span class="o">.</span><span class="n">tspan</span>
    <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="n">n</span>
    <span class="n">t</span> <span class="o">=</span> <span class="p">[</span> <span class="n">a</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">h</span> <span class="k">for</span> <span class="n">i</span> <span class="kp">in</span> <span class="mi">0</span><span class="o">:</span><span class="n">n</span> <span class="p">]</span>

    <span class="c"># Initialize output.</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">fill</span><span class="p">(</span><span class="n">float</span><span class="p">(</span><span class="n">ivp</span><span class="o">.</span><span class="n">u0</span><span class="p">),</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="c"># Time stepping.</span>
    <span class="k">for</span> <span class="n">i</span> <span class="kp">in</span> <span class="mi">1</span><span class="o">:</span><span class="n">n</span>
        <span class="n">k1</span> <span class="o">=</span> <span class="n">h</span><span class="o">*</span><span class="n">ivp</span><span class="o">.</span><span class="n">f</span><span class="p">(</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>      <span class="n">ivp</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>     <span class="p">)</span>
        <span class="n">k2</span> <span class="o">=</span> <span class="n">h</span><span class="o">*</span><span class="n">ivp</span><span class="o">.</span><span class="n">f</span><span class="p">(</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">k1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">ivp</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span> <span class="p">)</span>
        <span class="n">k3</span> <span class="o">=</span> <span class="n">h</span><span class="o">*</span><span class="n">ivp</span><span class="o">.</span><span class="n">f</span><span class="p">(</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">k2</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">ivp</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span> <span class="p">)</span>
        <span class="n">k4</span> <span class="o">=</span> <span class="n">h</span><span class="o">*</span><span class="n">ivp</span><span class="o">.</span><span class="n">f</span><span class="p">(</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">k3</span><span class="p">,</span>   <span class="n">ivp</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">h</span>   <span class="p">)</span>
        <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">k1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">k2</span> <span class="o">+</span> <span class="n">k3</span><span class="p">)</span> <span class="o">+</span> <span class="n">k4</span><span class="p">)</span><span class="o">/</span><span class="mi">6</span>
    <span class="k">end</span>
    <span class="k">return</span> <span class="n">t</span><span class="p">,</span><span class="n">u</span>
<span class="k">end</span>
</pre></div>
</td></tr></table></div>
</div></div></div>
<div class="section" id="efficiency">
<h2>Efficiency<a class="headerlink" href="#efficiency" title="Permalink to this headline">¶</a></h2>
<p>As with rootfinding and integration, the usual point of view is that evaluations of <span class="math notranslate nohighlight">\(f\)</span> are the only significant computations and are therefore to be minimized in number. One of the most important characteristics of a multistage method is that each stage requires an evaluation of <span class="math notranslate nohighlight">\(f\)</span>; that is, a single time step of an <span class="math notranslate nohighlight">\(s\)</span>-stage method requires <span class="math notranslate nohighlight">\(s\)</span> evaluations of <span class="math notranslate nohighlight">\(f\)</span>.</p>
<p>The error decreases <em>geometrically</em> as the number of stages grows algebraically, so trading a stage for an increase in order is a good deal. But  <span class="math notranslate nohighlight">\(s=5\)</span>, <span class="math notranslate nohighlight">\(6\)</span>, or <span class="math notranslate nohighlight">\(7\)</span> gives a maximal order of accuracy of <span class="math notranslate nohighlight">\(s-1\)</span>; this decreases to <span class="math notranslate nohighlight">\(s-2\)</span> for <span class="math notranslate nohighlight">\(s=8\)</span> and <span class="math notranslate nohighlight">\(s=9\)</span>, etc. Fourth order is considered adequate and the “sweet spot” for many applications.</p>
</div>
<div class="section" id="exercises">
<h2>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">¶</a></h2>
<ol id="problem-rkhandexamples">
<li><p>✍ For each IVP, write out (possibly using a calculator) the first time step of the improved Euler method with <span class="math notranslate nohighlight">\(h=0.2\)</span>.</p>
<p><strong>(a)</strong> <span class="math notranslate nohighlight">\(u' = -2t u, \ 0 \le t \le 2, \ u(0) = 2;\  \hat{u}(t) = 2e^{-t^2}\)</span></p>
<p><strong>(b)</strong> <span class="math notranslate nohighlight">\(u' = u + t, \ 0 \le t \le 1, \ u(0) = 2;\  \hat{u}(t) = -1-t+3e^t\)</span></p>
<p><strong>(c)</strong> <span class="math notranslate nohighlight">\((1+x^3)uu' = x^2,\ 0 \le x \le 3, \ u(0) = 1;\ \hat{u}(x) = [1+(2/3)\ln (1+x^3)]^{1/2}\)</span></p>
</li>
<li><p>✍ Use the modified Euler method to solve the problems in the preceding exercise.</p>
</li>
<li><p>✍ Use Heun’s method to solve the problems in <a class="reference internal" href="#problem-rkhandexamples"><span class="std std-ref">exercise 1 above</span></a>.</p>
</li>
<li><p>✍ Use RK4 to solve the problems in <a class="reference internal" href="#problem-rkhandexamples"><span class="std std-ref">exercise 1 above</span></a>.</p>
</li>
<li><p>✍ Using <a class="reference internal" href="#equation-rkexactexpand">(179)</a> and <a class="reference internal" href="#equation-mvtaylor2">(180)</a>, show that Heun’s method has order of accuracy at least two.</p>
</li>
<li><p>✍ Using <a class="reference internal" href="#equation-rkexactexpand">(179)</a> and <a class="reference internal" href="#equation-mvtaylor2">(180)</a>, show that the modified Euler method has order of accuracy at least two.</p>
</li>
<li id="problem-rk4converge"><p>⌨ For each IVP, compute the solution using <a class="reference internal" href="#function-rk4"><span class="std std-ref">rk4</span></a>. (i) Plot the solution for <span class="math notranslate nohighlight">\(n=300\)</span>. (ii) For <span class="math notranslate nohighlight">\(n=100,200,300,\ldots,1000\)</span>, compute the error at the final time and make a log–log convergence plot, including a reference line for 4th-order convergence.</p>
<p><strong>(a)</strong> <span class="math notranslate nohighlight">\(u''+ 9u = 9t, \: 0&lt; t&lt; 2\pi, \: u(0) = 1,\: u'(0) = 1; \: \hat{u}(t) = t+\cos (3t)\)</span></p>
<p><strong>(b)</strong> <span class="math notranslate nohighlight">\(u''+ 9u = \sin(2t), \: 0&lt; t&lt; 2\pi, \: u(0) = 2,\: u'(0) = 1\)</span>;</p>
<p><span class="math notranslate nohighlight">\(\quad \hat{u}(t) = (1/5) \sin(3t) + 2 \cos (3t)+  (1/5) \sin (2t)\)</span></p>
<p><strong>(c)</strong> <span class="math notranslate nohighlight">\(u''- 9u = 9t, \: 0&lt; t&lt; 1, \: u(0) = 2,\: u'(0) = -1; \: \hat{u}(t) = e^{3t} + e^{-3t}-t\)</span></p>
<p><strong>(d)</strong> <span class="math notranslate nohighlight">\(u''+ 4u'+ 4u = t, \: 0&lt; t&lt; 4, \: u(0) = 1,\: u'(0) = 3/4; \: \hat{u}(t) = (3t+5/4)e^{-2t} + (t-1)/4\)</span></p>
<p><strong>(e)</strong> <span class="math notranslate nohighlight">\(x^2 y'' +5xy' + 4y = 0,\: 1&lt;x&lt;e^2, \: y(1) = 1, \: y'(1) = -1, \: \hat{y}(x) = x^{-2}( 1 + \ln x)\)</span></p>
<p><strong>(f)</strong> <span class="math notranslate nohighlight">\(2 x^2 y'' +3xy' - y = 0,\: 1&lt;x&lt;16, \: y(1) = 4, \: y'(1) = -1, \: \hat{y}(x) = 2(x^{1/2} + x^{-1})\)</span></p>
<p><strong>(g)</strong> <span class="math notranslate nohighlight">\(x^2 y'' -xy' + 2y = 0,\: 1&lt;x&lt;e^{\pi}, \: y(1) = 3, \: y'(1) = 4\)</span>;</p>
<p><span class="math notranslate nohighlight">\(\quad \hat{y}(x) = x \left[ 3 \cos \left( \ln x \right)+\sin \left( \ln x \right) \right]\)</span></p>
<p><strong>(h)</strong> <span class="math notranslate nohighlight">\(x^2 y'' + 3xy' + 4y = 0,\: e^{\pi/12} &lt; x &lt; e^{\pi}, \: y(e^{\pi/12}) = 0,  \: y'(e^{\pi/12}) = -6\)</span>;</p>
<p><span class="math notranslate nohighlight">\(\quad \hat{y}(x) = x^{-1} \left[ 3 \cos \left( 3 \ln x \right)+\sin \left( 3 \ln x \right) \right]\)</span></p>
</li>
<li><p>⌨ Do the <a class="reference internal" href="systems.html#problem-sir"><span class="std std-ref">SIR model exercise</span></a>, but using <a class="reference internal" href="#function-rk4"><span class="std std-ref">rk4</span></a> instead of <code class="docutils literal notranslate"><span class="pre">solve</span></code>.</p>
</li>
<li><p>⌨ Do the <a class="reference internal" href="systems.html#problem-fitznag"><span class="std std-ref">FitzHugh--Nagumo model exercise</span></a>, but using <a class="reference internal" href="#function-rk4"><span class="std std-ref">rk4</span></a> instead of <code class="docutils literal notranslate"><span class="pre">solve</span></code>.</p>
</li>
<li><p>✍ Consider the problem <span class="math notranslate nohighlight">\(u'=ku\)</span>, <span class="math notranslate nohighlight">\(u(0) = 1\)</span> for constant <span class="math notranslate nohighlight">\(k\)</span> and <span class="math notranslate nohighlight">\(t&gt;0\)</span>.</p>
<p><strong>(a)</strong> Find an explicit formula in terms of <span class="math notranslate nohighlight">\(h\)</span> and <span class="math notranslate nohighlight">\(k\)</span> for <span class="math notranslate nohighlight">\(u_{i+1}/u_i\)</span> in the modified Euler solution.</p>
<p><strong>(b)</strong> Find values of <span class="math notranslate nohighlight">\(k\)</span> and <span class="math notranslate nohighlight">\(h\)</span> such that <span class="math notranslate nohighlight">\(|u_i|\to\infty\)</span> as <span class="math notranslate nohighlight">\(i\to\infty\)</span> while the exact solution <span class="math notranslate nohighlight">\(\hat{u}(t)\)</span> is bounded as <span class="math notranslate nohighlight">\(t\to\infty\)</span>.</p>
</li>
<li><p>⌨ Modify <a class="reference internal" href="#function-rk4"><span class="std std-ref">rk4</span></a> to implement Heun’s method. Test your function on <span class="math notranslate nohighlight">\(2 x^2 y'' +3x y' - y = 0\)</span> over <span class="math notranslate nohighlight">\([1,16]\)</span>, with <span class="math notranslate nohighlight">\(y(1) = 4\)</span>, <span class="math notranslate nohighlight">\(y'(1) = -1\)</span>. Use the exact solution <span class="math notranslate nohighlight">\(\hat{y}(x) = 2(x^{1/2} + x^{-1})\)</span> to show that the error at <span class="math notranslate nohighlight">\(x=16\)</span> converges at second order.</p>
</li>
</ol>
<hr class="docutils" />
<dl class="footnote brackets">
<dt class="label" id="rk"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Americans tend to pronounce these German names as “run-ghuh kut-tah.”</p>
</dd>
</dl>
</div>
</div>


              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="systems.html" title="previous page">Systems of differential equations</a>
    <a class='right-next' id="next-link" href="adaptive.html" title="next page">Adaptive Runge–Kutta</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Tobin A. Driscoll and Richard J. Braun<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    <script src="../_static/js/index.js"></script>
    
  </body>
</html>
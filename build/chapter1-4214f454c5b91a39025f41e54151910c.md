---
kernelspec:
  display_name: Python 3
  language: python
  name: python3
---

```{code-cell} ipython3
from scipy import *
import numpy as np
import FNC
```

(demo-float-accuracy-julia)=
``````{dropdown} Floating-point accuracy
Recall the grade-school approximation to the number $\pi$.

```{code-cell} ipython3
p = 22/7
print(p)
```
::::{grid} 1 1 2 2
:::{grid-item}
:columns: 5

Not all the digits displayed for `p` are the same as those of $\pi$. 

:::
:::{grid-item-card}
:columns: 7

The value of `pi` is predefined in the `numpy` package, which is typically abbreviated as `np`.
:::
::::

```{code-cell} ipython3
print(np.pi)
```

::::{grid} 1 1 2 2

:::{grid-item}
:columns: 5

The absolute and relative accuracies of the approximation are as follows:

:::
:::{grid-item-card}
:columns: 7

We often use [Python f-strings](https://docs.python.org/3/tutorial/inputoutput.html#tut-f-strings) to format numerical output. 

:::
::::


```{code-cell} ipython3
print(f"absolute accuracy: {abs(p - np.pi)}")
```

```{code-cell} ipython3
rel_acc = abs(p - np.pi) / np.pi
print("relative accuracy: {rel_acc:.4e}")
```

::::{grid} 1 1 2 2

:::{grid-item}
:columns: 5

Here we calculate the number of accurate digits in `p`:

:::
:::{grid-item-card}
:columns: 7

The `np.log` function is for the natural log. For other common bases, use `log10` or `log2`.

:::
::::


```{code-cell} ipython3
print(f"accurate digits: {-np.log10(rel_acc):.1f}")
```
``````

# Example 1.1.3

+++

There is no double precision number between $1$ and $1+\varepsilon_\text{mach}$. Thus the following difference is zero despite its appearance.

```{code-cell} ipython3
eps = finfo(float).eps
e = eps/2
(1.0 + e) - 1.0
```

However, $1-\varepsilon_\text{mach}/2$ is a double precision number, so it and its negative are represented exactly:

```{code-cell} ipython3
1.0 + (e - 1.0)
```

This is now the "correct" result. But we have found a rather shocking breakdown of the associative law of addition!

+++

# Example 1.3.2

+++

Here we show how to use `horner` to evaluate a polynomial. We first define a vector of the coefficients of $p(x)=(x−1)^3=x^3−3x^2+3x−1$, in descending degree order. Note that the textbook's functions are all in a namespace called `FNC`, to help distinguish them from other Python commands and modules.

```{code-cell} ipython3
c = np.array([1,-3,3,-1])
print( FNC.horner(c,1.6) )
```

The above is the value of $p(1.6)$, up to a rounding error.

+++

# Example 1.3.3

+++

Our first step is to construct a polynomial with six known roots.

```{code-cell} ipython3
r = [-2.0,-1,1,1,3,6]
p = np.poly(r)
print(p)
```

Now we use a standard numerical method for finding those roots, pretending that we don't know them already.

```{code-cell} ipython3
r_computed = np.sort(poly1d(p).roots)
print(r_computed)
```

Here are the relative errors in each of the computed roots.

```{code-cell} ipython3
print(abs(r - r_computed) / r)
```

It seems that the forward error is acceptably close to machine epsilon for double precision in all cases except the double root at $x=1$. This is not a surprise, though, given the poor conditioning at such roots.

Let's consider the backward error. The data in the rootfinding problem are the polynomial coefficients. We can apply poly to find the coefficients of the polynomial (that is, the data) whose roots were actually computed by the numerical algorithm.

```{code-cell} ipython3
p_computed = np.poly(r_computed)
print(p_computed)
```

We find that in a relative sense, these coefficients are very close to those of the original, exact polynomial:

```{code-cell} ipython3
print(abs(p-p_computed)/p)
```

In summary, even though there are some computed roots relatively far from their correct values, they are nevertheless the roots of a polynomial that is very close to the original.

+++

# Example 1.3.4

```{code-cell} ipython3
a = 1.0
b = -(1e6+1e-6)
c = 1.0
```

```{code-cell} ipython3
x1 = (-b + np.sqrt(b*b-4*a*c)) / (2*a)
print(x1)
```

So far, so good. But:

```{code-cell} ipython3
x2 = (-b - np.sqrt(b*b-4*a*c)) / (2*a)
print(x2)
```

The first value is correct to all stored digits, but the second has fewer than six accurate digits:

```{code-cell} ipython3
print( -np.log10(abs(1e-6-x2)/1e-6 ) )
```

# Example 1.3.5

```{code-cell} ipython3
a = 1.0
b = -(1e6+1e-6)
c = 1.0
```

First, we find the "good" root using the quadratic forumla. 

```{code-cell} ipython3
x1 = (-b + np.sqrt(b*b-4*a*c)) / (2*a)
print(x1)
```

Then we use the alternative formula for computing the other root. 

```{code-cell} ipython3
x2 = c/(a*x1)
print(x2 - 1e-6)
```

```{code-cell} ipython3

```

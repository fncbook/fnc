---
kernelspec:
  display_name: Python 3
  language: python
  name: python3
numbering:
  headings: false
---
# Chapter 6

## Functions

(function-euler-python)=
``````{dropdown} Euler's method for an initial-value problem
```{literalinclude} ../python/pkg/FNC/FNC06.py
:filename: euler.py
:start-line: 4
:end-line: 19
:language: python
:linenos: true
```
``````

(function-ie2-python)=
``````{dropdown} Improved Euler method for an IVP
```{literalinclude} ../python/pkg/FNC/FNC06.py
:filename: ie2.py
:start-line: 43
:end-line: 65
:language: python
:linenos: true
```
``````

(function-rk4-python)=
``````{dropdown} Fourth-order Runge-Kutta for an IVP
```{literalinclude} ../python/pkg/FNC/FNC06.py
:filename: rk4.py
:start-line: 67
:end-line: 91
:language: python
:linenos: true
```
``````

(function-rk23-python)=
``````{dropdown} Adaptive IVP solver based on embedded RK formulas
```{literalinclude} ../python/pkg/FNC/FNC06.py
:filename: rk23.py
:start-line: 93
:end-line: 137
:language: python
:linenos: true
```
::::{admonition} About the code
:class: dropdown
The check `t[i]+h==t[i]`on line 19 is to detect when $h$ has become so small that it no longer changes the floating-point value of $t_i$. This may be a sign that the underlying exact solution has a singularity near $t=t_i$, but in any case, the solver must halt by using a `break` statement to exit the loop.

On line 30, we use a combination of absolute and relative tolerances to judge the acceptability of a solution value, as in {eq}`absreltolerance`. In lines 41--43 we underestimate the step factor $q$ a bit and prevent a huge increase in the step size, since a rejected step is expensive, and then we make sure that our final step doesn't take us past the end of the domain.

Finally, line 37 exploits a subtle property of the BS23 formula called *first same as last* (FSAL).
While {eq}`bs23` calls for four stages to find the paired second- and third-order estimates, the final stage computed in stepping from $t_i$ to $t_{i+1}$ is identical to the first stage needed to step from $t_{i+1}$ to $t_{i+2}$. By repurposing `s₄` as `s₁` for the next pass, one of the stage evaluations comes for free, and only three evaluations of $f$ are needed per successful step.
::::

``````

(function-ab4-python)=
``````{dropdown} 4th-order Adams–Bashforth formula for an IVP
```{literalinclude} ../python/pkg/FNC/FNC06.py
:filename: ab4.py
:start-line: 139
:end-line: 167
:language: python
:linenos: true
```
::::{admonition} About the code
:class: dropdown
Line 15 sets `σ` to be the coefficients of the generating polynomial $\sigma(z)$ of AB4. Lines 19--21 set up the IVP over the time interval $a \le t \le a+3 h$, call `rk4` to solve it using the step size $h$, and use the result to fill the first four values of the solution. Then line 24 computes the vector $[f_2,f_1,f_0]$.

Line 28 computes $f_i$, based on the most recent solution value and time. That goes into the first spot of `f`, followed by the three values that were previously most recent. These are the four values that appear in {eq}`ab4`. Each particular $f_i$ value starts at the front of `f`, moves through each position in the vector over three iterations, and then is forgotten.
::::
``````

(function-am2-python)=
``````{dropdown} 2nd-order Adams–Moulton (trapezoid) formula for an IVP
```{literalinclude} ../python/pkg/FNC/FNC06.py
:filename: am2.py
:start-line: 169
:end-line: 193
:language: python
:linenos: true
```
::::{admonition} About the code
:class: dropdown
Lines 22-23 define the function $\mathbf{g}$ and call `levenberg` to find the new solution value, using an Euler half-step as its starting value. A robust code would have to intercept the case where `levenberg` fails to converge, but we have ignored this issue for the sake of brevity.
::::
``````

## Examples

```{code-cell} ipython3
from numpy import *
from numpy.linalg import norm
from matplotlib.pyplot import *
from prettytable import PrettyTable
import sys
sys.path.append('pkg/')
import FNC
import importlib
importlib.reload(FNC)
```

```{code-cell} ipython3
:tags: [remove-cell]
# This (optional) block is for improving the display of plots.
rcParams["figure.figsize"] = [7, 4]
rcParams["lines.linewidth"] = 2
rcParams["lines.markersize"] = 4
rcParams['animation.html'] = "jshtml"  # or try "html5"
``` 

### Section 6.1

(demo-basics-first-python)=
``````{dropdown} Solving an IVP
Let's use `solve_ivp` from `scipy.integrate` to define and solve an initial-value problem for $u'=\sin[(u+t)^2]$ over $t \in [0,4]$, such that $u(0)=-1$.

To create an initial-value problem for $u(t)$, you must supply a function that computes $u'$, an initial value for $u$, and the endpoints of the interval for $t$. The $t$ interval should be defined as `(a,b)`, where at least one of the values is a float.

```{index} ! Julia; ODEProblem, ! Julia; solve
```

```{code-cell}
f = lambda t, u: sin((t + u) ** 2)
tspan = [0.0, 4.0]
u0 = [-1.0]
```

Note above that even though this is a problem for a scalar function $u(t)$, we had to set the initial condition as a "one-dimensional vector."

```{code-cell}
from scipy.integrate import solve_ivp
sol = solve_ivp(f, tspan, u0)
```

The resulting solution object has fields `t` and `y` that contain the values of the independent and dependent variables, respectively; those field names are the same regardless of what we use in our own codes.

```{code-cell}
print("t shape:", sol.t.shape)
print("u shape:", sol.y.shape)
plot(sol.t, sol.y[0, :], "-o")
xlabel("$t$"), ylabel("$u(t)$")
title("Solution of $u' = sin((t+u)^2)$")
```

You can see above that the solution was not computed at enough points to make a smooth graph. There is a way to request output at times of your choosing.

```{code-cell}
sol = solve_ivp(f, tspan, u0, t_eval=linspace(0, 4, 200))
plot(sol.t, sol.y[0, :], "-")
xlabel("$t$"), ylabel("$u(t)$")
title("Solution of $u' = sin((t+u)^2)$")
```

Another option is to enable interpolation to evaluate the solution anywhere after the fact:

```{code-cell}
sol = solve_ivp(f, tspan, u0, dense_output=True)
for t in linspace(0, 4, 6):
    print(f"u({t:.2f}) = {sol.sol(t)[0]:.4f}")
```
``````

(demo-basics-sing-python)=
``````{dropdown} Finite-time singularity

::::{grid} 1 1 2 2
The equation $u'=(u+t)^2$ gives us some trouble.
:::{card}
It's a good idea to check `sol.success` after calling `solve_ivp`. If it's `False`, the solution may not be reliable. 
:::
::::

```{code-cell}
f = lambda t, u: (t + u) ** 2
sol = solve_ivp(f, [0.0, 1.0], [1.0])
if not sol.success:
    print(sol.message)
```

The warning message we received can mean that there is a bug in the formulation of the problem. But if everything has been done correctly, it suggests that the solution may not exist past the indicated time. This is a possibility in nonlinear ODEs.

```{code-cell}
semilogy(sol.t, sol.y[0, :])
xlabel("$t$")
ylabel("$u(t)$")
title("Blowup in finite time")
```
``````

(demo-basics-cond-python)=
``````{dropdown} Conditioning of an IVP
Consider the ODEs $u'=u$ and $u'=-u$. In each case we compute $\partial f/\partial u = \pm 1$, so the condition number bound from {numref}`Theorem %s <theorem-depIC>` is $e^{b-a}$ in both problems. However, they behave quite differently. In the case of exponential growth, $u'=u$, the bound is the actual condition number.

```{code-cell}
t = linspace(0, 3, 200)
u = array([exp(t) * u0 for u0 in [0.7, 1, 1.3]])
plot(t, u.T)
xlabel("$t$")
ylabel("$u(t)$")
title("Exponential divergence of solutions")
```

But with $u'=-u$, solutions actually get closer together with time.

```{code-cell}
t = linspace(0, 3, 200)
u = array([exp(-t) * u0 for u0 in [0.7, 1, 1.3]])
plot(t, u.T)
xlabel("$t$")
ylabel("$u(t)$")
title("Exponential convergence of solutions")
```

In this case the actual condition number is one, because the initial difference between solutions is the largest over all time. Hence, the exponentially growing upper bound $e^{b-a}$ is a gross overestimate.
``````

(demo-euler-converge-python)=
``````{dropdown} Convergence of Euler's method
We consider the IVP $u'=\sin[(u+t)^2]$ over $0\le t \le 4$, with $u(0)=-1$.

```{code-cell}
f = lambda t, u: sin((t + u) ** 2)
tspan = [0.0, 4.0]
u0 = -1.0
t, u = FNC.euler(f, tspan, u0, 20)

fig, ax = subplots()
ax.plot(t, u, "-o", label="$n=20$")
xlabel("$t$"), ylabel("$u(t)$")
title("Solution by Euler's method")
legend()
```

We could define a different interpolant to get a smoother picture above, but the derivation of Euler's method assumed a piecewise linear interpolant. We can instead request more steps to make the interpolant look smoother.

```{code-cell}
t, u = FNC.euler(f, tspan, u0, 200)
ax.plot(t, u, label="$n=200$")
ax.legend()
fig
```

Increasing $n$ changed the solution noticeably. Since we know that interpolants and finite differences become more accurate as $h\to 0$, we should anticipate the same behavior from Euler's method. We don't have an exact solution to compare to, so we will use `solve_ivp` to construct an accurate reference solution.

```{code-cell}
from scipy.integrate import solve_ivp
sol = solve_ivp(f, tspan, [u0], dense_output=True, atol=1e-8, rtol=1e-8)
ax.plot(t, sol.sol(t)[0], "--", label="accurate")
ax.legend()
fig
```

Now we can perform a convergence study.

```{code-cell}
n_ = array([int(5 * 10**k) for k in arange(0, 3, 0.5)])
err_ = zeros(6)
results = PrettyTable(["n", "error"])
for j, n in enumerate(n_):
    t, u = FNC.euler(f, tspan, u0, n)
    err_[j] = norm(sol.sol(t)[0] - u, inf)
    results.add_row((n, err_[j]))
print(results)
```

The error is approximately cut by a factor of 10 for each increase in $n$ by the same factor. A log-log plot also confirms first-order convergence. Keep in mind that since $h=(b-a)/n$, it follows that $O(h)=O(n^{-1})$.

```{code-cell}
loglog(n_, err_, "-o", label="results")
plot(n_, 0.5 * (n_ / n_[0])**(-1), "--", label="1st order")
xlabel("$n$"), ylabel("inf-norm error")
title("Convergence of Euler's method")
legend()
```
``````

(demo-systems-predator-python)=
``````{dropdown} Predator-prey model
We encode the predator–prey equations via a function.

```{code-cell}
def predprey(t, u):
    y, z = u                        # rename for convenience
    s = (y * z) / (1 + beta * y)    # appears in both equations
    return array([y * (1 - alpha * y) - s, -z + s])
```

As before, the ODE function must accept three inputs, `u`, `p`, and `t`, even though in this case there is no explicit dependence on `t`. The second input is used to pass parameters that don't change throughout a single instance of the problem.

To specify the IVP we must also provide the initial condition, which is a 2-vector here, and the interval for the independent variable. These are given in the call to `solve_ivp`.

```{code-cell}
from scipy.integrate import solve_ivp
u0 = array([1, 0.01])
tspan = [0.0, 80.0]
alpha, beta = 0.1, 0.25
sol = solve_ivp(predprey, tspan, u0, dense_output=True)
print(f"solved with {sol.y.shape[1]} time steps")
```

As in scalar problems, the solution object has fields `t` and `y` that contain the values of the independent and dependent variables, respectively. Each row of `y` represents one component of the solution at every time step, and each column of `y` is the entire solution vector at one time step. Since we used `dense_output=True`, there is also a method `sol` that can be used to evaluate the solution at any time. 

```{code-cell}
t = linspace(0, 80, 1200)
u = vstack([sol.sol(t[i]) for i in range(t.size)]).T    # same shape as sol.y
fig, ax = subplots()
ax.plot(t, u[0, :], label="prey")
ax.plot(t, u[1, :], label="predator")
xlabel("$t$"), ylabel("population")
title("Predator-prey solution")
```

We can also use {numref}`Function {number} <function-euler>` to find the solution.

```{code-cell}
t_E, u_E = FNC.euler(predprey, tspan, u0, 800)
ax.scatter(t_E, u_E[0, :], label="prey (Euler)", s=1)
ax.scatter(t_E, u_E[1, :], label="predator (Euler)", s=2)
ax.legend()
fig
```

You can see above that the Euler solution is not very accurate. When the solution has two components, it's common to plot the it in the _phase plane_, i.e., with $u_1$ and $u_2$ along the axes and time as a parameterization of the curve.

```{code-cell}
plot(u[0, :], u[1, :])
xlabel("prey"), ylabel("predator")
title("Predator-prey phase plane")
```
From this plot we can see that the solution approaches a periodic one, which in the phase plane is represented by a closed path.
``````

(demo-systems-coupledpendula-python)=
``````{dropdown} Coupled pendulums
Let's implement the coupled pendulums from {numref}`Example {number} <example-systems-coupledpendula>`. The pendulums will be pulled in opposite directions and then released together from rest.

```{code-cell}
def couple(t, u, params):
    gamma, L, k = params
    g = 9.8
    udot = copy(u)
    udot[:2] = u[2:4]
    udot[2] = -gamma * u[2] - (g / L) * sin(u[0]) + k * (u[1] - u[0])
    udot[3] = -gamma * u[3] - (g / L) * sin(u[1]) + k * (u[0] - u[1])
    return udot

u0 = array([1.25, -0.5, 0, 0])
tspan = [0.0, 50.0]
```

::::{grid} 1 1 2 2
First we check the behavior of the system when the pendulums are uncoupled, i.e., when $k=0$.
:::{card}
We use a closure here to pass the fixed parameter values into `couple`.
:::
::::

```{code-cell}
gamma, L, k = 0.01, 0.5, 0.0
du_dt = lambda t, u: couple(t, u, (gamma, L, k))
sol = solve_ivp(du_dt, tspan, u0, t_eval=linspace(0, 50, 1000))
plot(sol.t, sol.y[:2, :].T)    # first two components of solution
xlabel("t"), ylabel("angle")
title("Uncoupled pendulums");
```

You can see that the pendulums swing independently. Because the model is nonlinear and the initial angles are not small, they have slightly different periods of oscillation, and they go in and out of phase.

With coupling activated, a different behavior is seen.

```{code-cell}
k = 0.75    # changes the value in the du_dt closure
sol = solve_ivp(du_dt, tspan, u0, t_eval=linspace(0, 50, 1000))
plot(sol.t, sol.y[:2, :].T)
xlabel("t"), ylabel("angle")
title("Coupled pendulums");
```

The coupling makes the pendulums swap energy back and forth.
``````

(demo-rk-converge-python)=
We solve the IVP $u'=\sin[(u+t)^2]$ over $0\le t \le 4$, with $u(0)=-1$. We start by getting a reference solution to validate against.

```{code-cell}
from scipy.integrate import solve_ivp
du_dt = lambda t, u: sin((t + u)**2)
tspan = (0.0, 4.0)
u0 = -1.0
u_ref = solve_ivp(du_dt, tspan, [u0], dense_output=True, atol=5e-14, rtol=5e-14)
```

Now we perform a convergence study of our two Runge–Kutta implementations.

```{code-cell}
n = [int(2 * 10**k) for k in linspacee(0, 3, 7)]
err = {"IE2" : [], "RK4" : []}
results = PrettyTable(["n", "IE2 error", "RK4 error"])
for i in range(len(n)):
    t, u = FNC.ie2(du_dt, tspan, u0, n[i])
    err["IE2"].append(norm(u_ref.sol(t) - u, inf))
    t, u = FNC.rk4(du_dt, tspan, u0, n[i])
    err["RK4"].append(norm(u_ref.sol(t) - u, inf))
    results.add_row([n[i], err["IE2"][-1], err["RK4"][-1]])

print(results)
```

The amount of computational work at each time step is assumed to be proportional to the number of stages. Let's compare on an apples-to-apples basis by using the number of $f$-evaluations on the horizontal axis.

```{code-cell}
print(n)
print(err)
loglog(2 * n, err["IE2"], "-o", label="IE2")
loglog(4 * n, err["RK4"], "-o", label="RK4")
plot(2 * n, 0.01 * (n / n[0])**(-2), "--", label="2nd order")
plot(4 * n, 1e-6 * (n / n[0])**(-4), "--", label="4th order")

xlabel("f-evaluations"),  ylabel("inf-norm error")
legend()
title("Convergence of RK methods");
```

The fourth-order variant is more efficient in this problem over a wide range of accuracy.

(demo-adapt-basic-python)=
``````{dropdown} Adaptive step size
Let's run adaptive RK on  $u'=e^{t-u\sin u}$.

```{code-cell}
f(u, p, t) = exp(t - u * sin(u))
ivp = ODEProblem(f, 0, (0.0, 5.0))
t, u = FNC.rk23(ivp, 1e-5)

plot(t, u, m=2,
    xlabel=L"t", ylabel=L"u(t)", title="Adaptive IVP solution")
```

The solution makes a very abrupt change near $t=2.4$. The resulting time steps vary over three orders of magnitude.

```{code-cell}
Δt = diff(t)
plot(t[1:end-1], Δt, title="Adaptive step sizes",
    xaxis=(L"t", (0, 5)), yaxis=(:log10, "step size"))
```

If we had to run with a uniform step size to get this accuracy, it would be

```{code-cell}
println("minimum step size = $(minimum(Δt))")
```

On the other hand, the average step size that was actually taken was

```{code-cell}
println("average step size = $(sum(Δt)/(length(t)-1))")
```

We took fewer steps by a factor of almost 1000! Even accounting for the extra stage per step and the occasional rejected step, the savings are clear.

``````

(demo-adpat-sing-python)=
``````{dropdown} Adaptive step size near a singularity
In {numref}`Demo %s <demo-basics-sing>` we saw an IVP that appears to blow up in a finite amount of time. Because the solution increases so rapidly as it approaches the blowup, adaptive stepping is required even to get close.

```{code-cell}
f(u, p, t) = (t + u)^2
ivp = ODEProblem(f, 1, (0.0, 1.0))
t, u = FNC.rk23(ivp, 1e-5);
```

In fact, the failure of the adaptivity gives a decent idea of when the singularity occurs.

```{code-cell}
plot(t, u, legend=:none,
    xlabel=L"t", yaxis=(:log10, L"u(t)"), title="Finite-time blowup")

tf = t[end]
vline!([tf], l=:dash)
annotate!(tf, 1e5, latexstring(@sprintf("t = %.6f ", tf)), :right)
```
``````

(demo-implicit-ab4-python)=
``````{dropdown} Convergence of Adams–Bashforth
We study the convergence of AB4 using the IVP $u'=\sin[(u+t)^2]$ over $0\le t \le 4$, with $u(0)=-1$. As usual, `solve` is called to give an accurate reference solution.

```{code-cell}
ivp = ODEProblem((u, p, t) -> sin((t + u)^2), -1.0, (0.0, 4.0))
u_ref = solve(ivp, Tsit5(), reltol=1e-14, abstol=1e-14);
```

Now we perform a convergence study of the AB4 code.

```{code-cell}
n = @. [round(Int, 4 * 10^k) for k in 0:0.5:3]
err = []
for n in n
    t, u = FNC.ab4(ivp, n)
    push!(err, norm(u_ref.(t) - u, Inf))
end

pretty_table([n err], header=["n", "inf-norm error"])
```

The method should converge as $O(h^4)$, so a log-log scale is appropriate for the errors.

```{code-cell}
plot(n, err, m=3, label="AB4",
    xaxis=(:log10, L"n"), yaxis=(:log10, "inf-norm error"),
    title="Convergence of AB4", leg=:bottomleft)

plot!(n, (n / n[1]) .^ (-4), l=:dash, label=L"O(n^{-4})")
```
``````

(demo-implicit-stiff-python)=
``````{dropdown} Stiffness
The following simple ODE uncovers a surprise.

```{code-cell}
ivp = ODEProblem((u, p, t) -> u^2 - u^3, 0.005, (0, 400.0))
```

We will solve the problem first with the implicit AM2 method using $n=200$ steps.

```{code-cell}
tI, uI = FNC.am2(ivp, 200)

plot(tI, uI, label="AM2",
    xlabel=L"t", ylabel=L"u(t)", leg=:bottomright)
```

Now we repeat the process using the explicit AB4 method.

```{code-cell}
tE, uE = FNC.ab4(ivp, 200)

scatter!(tE, uE, m=3, label="AB4", ylim=[-4, 2])
```

Once the solution starts to take off, the AB4 result goes catastrophically wrong.

```{code-cell}
uE[105:111]
```

We hope that AB4 will converge in the limit $h\to 0$, so let's try using more steps.

```{code-cell}
plt = scatter(tI, uI, label="AM2, n=200", m=3,
    xlabel=L"t", ylabel=L"u(t)", leg=:bottomright)

for n in [1000, 1600]
    tE, uE = FNC.ab4(ivp, n)
    plot!(tE, uE, label="AM4, n=$n")
end
plt
```

So AB4, which is supposed to be _more_ accurate than AM2, actually needs something like 8 times as many steps to get a reasonable-looking answer!
``````

(demo-zs-LIAF-python)=
``````{dropdown} Instability
It is straightforward to check that the two-step method LIAF, defined by

```{math}
:label: LIAF
  \mathbf{u}_{i+1} = -4u_i + 5u_{i-1} + h(4f_i + 2f_{i-1}),
```

is third-order accurate. Let's apply it to the ridiculously simple IVP $u'=u$, $u(0)=1$, whose solution is $e^t$. We'll measure the error at the time $t=1$.

```{code-cell}
du_dt(u, t) = u
û = exp
a, b = 0.0, 1.0;
n = [5, 10, 20, 40, 60]
err = []
t, u = [], []
for n in n
    h = (b - a) / n
    t = [a + i * h for i in 0:n]
    u = [1; û(h); zeros(n - 1)]
    f_val = [du_dt(u[1], t[1]); zeros(n)]
    f_valor i in 2:n
        f_val[i] = du_dt(u[i], t[i])
        u[i+1] = -4 * u[i] + 5 * u[i-1] + h * (4 * f_val[i] + 2 * f_val[i-1])
    end
    push!(err, abs(û(b) - u[end]))
end

pretty_table([n (b - a) ./ n err], header=["n", "h", "error"])
```

The error starts out promisingly, but things explode from there. A graph of the last numerical attempt yields a clue.

```{code-cell}
plot(t, abs.(u), m=3, label="",
    xlabel=L"t", yaxis=(:log10, L"|u(t)|"), title="LIAF solution")
```

It's clear that the solution is growing exponentially in time.
``````

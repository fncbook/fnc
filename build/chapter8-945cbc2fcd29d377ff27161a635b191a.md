---
kernelspec:
  display_name: Python 3
  language: python
  name: python3
numbering:
  headings: false
---
# Chapter 8

## Functions

(function-poweriter-python)=
``````{dropdown} Power iteration
```{literalinclude} ../python/pkg/FNC/FNC08.py
:filename: poweriter.py
:start-at: def poweriter
:end-at: return gamma, x
:language: python
:linenos: true
```
``````

(function-inviter-python)=
``````{dropdown} Inverse iteration
```{literalinclude} ../python/pkg/FNC/FNC08.py
:filename: inviter.py
:start-at: def inviter
:end-at: return gamma, x
:language: python
:linenos: true
```
``````

(function-arnoldi-python)=
``````{dropdown} Arnoldi iteration
```{literalinclude} ../python/pkg/FNC/FNC08.py
:filename: arnoldi.py
:start-at: def arnoldi
:end-at: return Q, H
:language: python
:linenos: true
```

```{admonition} About the code
The loop starting at line 17 does not exactly implement {eq}`arnoldiip` and {eq}`arnoldigs`. The reason is numerical stability. Though the described and implemented versions are mathematically equivalent in exact arithmetic (see [Exercise 6](problem-subspace-modifiedgs)), the approach in {numref}`Function {number} <function-arnoldi>` is more stable.
```
``````

(function-gmres-python)=
``````{dropdown} GMRES
```{literalinclude} ../python/pkg/FNC/FNC08.py
:filename: gmres.py
:start-at: def arngmres
:end-at: return x, residual
:language: python
:linenos: true
```
``````

## Examples

```{code-cell} ipython3
from numpy import *
from numpy.linalg import norm
from matplotlib.pyplot import *
from prettytable import PrettyTable
import sys
sys.path.append('pkg/')
import FNC
import importlib
importlib.reload(FNC)
```

```{code-cell} ipython3
:tags: [remove-cell]
# This (optional) block is for improving the display of plots.
rcParams["figure.figsize"] = [7, 4]
rcParams["lines.linewidth"] = 2
rcParams["lines.markersize"] = 4
rcParams['animation.html'] = "jshtml"  # or try "html5"
``` 

### 8.1 @section-krylov-structure

(demo-structure-sparse-python)=
``````{dropdown} Sparsity
Here we load the adjacency matrix of a graph with 2790 nodes. Each node is a web page referring to Roswell, NM, and the edges represent links between web pages. (Credit goes to Panayiotis Tsaparas and the University of Toronto for making this data public.)

```{code-cell}
import scipy.sparse as sp
from scipy.io import loadmat

vars = loadmat("roswelladj.mat")    # get from the book's website
A = sp.csr_matrix(vars["A"])
```

We may define the density of $\mathbf{A}$ as the number of nonzeros divided by the total number of entries.

```{index} ! Python; nnz
```

```{code-cell}
m, n = A.shape
print(f"density is {A.nnz / (m * n):.3%}")
```

We can compare the storage space needed for the sparse $\mathbf{A}$ with the space needed for its dense / full counterpart.


```{code-cell}
F = A.todense()
print(f"{A.data.nbytes/1e6:.3f} MB for sparse form, {F.nbytes/1e6:.3f} MB for dense form")
```

Matrix-vector products are also much faster using the sparse form because operations with structural zeros are skipped.

```{code-cell}
from timeit import default_timer as timer
x = random.randn(n)
start = timer()
for i in range(1000):
    A @ x
print(f"sparse time: {timer() - start:.4g} sec")
```

```{code-cell}
start = timer()
for i in range(1000):
    F @ x
print(f"dense time: {timer() - start:.4g} sec")
```
``````

(demo-structure-fill-python)=
``````{dropdown} Fill-in of a sparse matrix

Here is the adjacency matrix of a graph representing a small-world network, featuring connections to neighbors and a small number of distant contacts.

```{code-cell}
import networkx as nx
wsg = nx.watts_strogatz_graph(200, 4, 0.02)
```

Because each node connects to relatively few others, the adjacency matrix is quite sparse.

```{code-cell}
A = nx.adjacency_matrix(wsg)
spy(A)
title("Adjacency matrix $A$");
```

::::{grid} 1 1 2 2
By {numref}`Theorem {number} <theorem-insight-adjmat>`, the entries of $\mathbf{A}^k$ give the number of walks of length $k$ between pairs of nodes, as with "*k* degrees of separation" within a social network. As $k$ grows, the density of $\mathbf{A}^k$ also grows.
:::{card}
While `A**6` is valid syntax here, it means elementwise power, not matrix power. 
:::

```{index} ! Python; matrix_power
```

```{code-cell}
from scipy.sparse.linalg import matrix_power
spy(matrix_power(A, 6))
title("$A^6$")
```
``````

(demo-structure-banded-python)=
``````{dropdown} Banded matrices

```{index} ! Julia; spdiagm
```

The `scipi.sparse.diags` function creates a sparse matrix given its diagonal elements and the diagonal indexes to put them on. The main or central diagonal is numbered zero, above and to the right of that is positive, and below and to the left is negative.

```{code-cell}
n = 50
data = [n * ones(n-3), ones(n), linspace(-1, 1-n, n-1)]
offsets = [-3, 0, 1]    # 3rd below, main, 1st above
A = sp.diags(data, offsets, format="lil")
print(A[:7, :7].todense())
```

Without pivoting, the LU factors have the same lower and upper bandwidth as the original matrix.

```{code-cell}
L, U = FNC.lufact(A.todense())
subplot(1, 2, 1), spy(L)
subplot(1, 2, 2), spy(U);
```

However, if we introduce row pivoting, bandedness may be expanded or destroyed.

```{code-cell}
L, U, p = FNC.plufact(A.todense())
subplot(1, 2, 1), spy(L[p, :])
subplot(1, 2, 2), spy(U)
```
``````

(demo-structure-linalg-python)=

``````{dropdown} Eigenvalues of sparse matrices
The following generates a random sparse matrix with prescribed eigenvalues.

```{code-cell}
n = 4000
density = 4e-4
ev = 1 / arange(1, n + 1)
A = FNC.sprandsym(n, density, eigvals=ev)
print(f"density is {A.nnz / prod(A.shape):.3%}")
```

```{index} ! Python; eigs
```

The `eigs` function finds a small number eigenvalues meeting some criterion. First, we ask for the 5 of largest (complex) magnitude using `which="LM"`.

```{code-cell}
from scipy.sparse.linalg import eigs
ev, V = eigs(A, k=5, which="LM")    # largest magnitude
print(1 / ev)
```

Now we find the 4 closest to the value 1 in the complex plane, via `sigma=1`.

```{code-cell}
from scipy.sparse.linalg import eigs
ev, V = eigs(A, k=4, sigma=0.03)    # closest to sigma
print(ev)
```

The time needed to solve a sparse linear system is not easy to predict unless you have some more information about the matrix. But it will typically be orders of magnitude faster than the dense version of the same problem.

```{code-cell}
from scipy.sparse.linalg import spsolve
x = 1 / arange(1, n + 1)
b = A @ x
start = timer()
xx = spsolve(A, b)
print(f"sparse time: {timer() - start:.3g} sec")
print(f"residual: {norm(b - A @ xx, 2):.1e}")
```

```{code-cell}
from numpy.linalg import solve
F = A.todense()
start = timer()
xx = solve(F, b)
print(f"dense time: {timer() - start:.3g} sec")
print(f"residual: {norm(b - A @ xx, 2):.1e}")
```
``````

### 8.2 @section-krylov-power

(demo-power-one-python)=
``````{dropdown} Power iteration
Here we choose a random 5×5 matrix and a random 5-vector.

```{code-cell}
A = random.choice(range(10), (5, 5))
A = A / sum(A, 0)
x = random.randn(5)
print(x)
```

Applying matrix-vector multiplication once doesn't do anything recognizable.

```{code-cell}
y = A @ x
print(y)
```

Repeating the multiplication still doesn't do anything obvious.

```{code-cell}
z = A @ y
print(z)
```

But if we keep repeating the matrix-vector multiplication, something remarkable happens: $\mathbf{A} \mathbf{x} \approx \mathbf{x}$.

```{code-cell}
x = random.randn(5)
for j in range(6):
    x = A @ x
print(x)
print(A @ x)
```

This phenomenon is unlikely to be a coincidence!

``````

(demo-power-iter-python)=
``````{dropdown} Convergence of power iteration
We will experiment with the power iteration on a 5×5 matrix with prescribed eigenvalues and dominant eigenvalue at 1.

```{code-cell}
ev = [1, -0.75, 0.6, -0.4, 0]
A = triu(ones([5, 5]), 1) + diag(ev)    # triangular matrix, eigs on diagonal
```

We run the power iteration 60 times. The first output should be a sequence of estimates converging to the dominant eigenvalue—which, in this case, we set up to be 1.

```{code-cell}
beta, x = FNC.poweriter(A, 60)
print(beta)
```

We check for linear convergence using a log-linear plot of the error.

```{code-cell}
err = 1 - beta
semilogy(arange(60), abs(err), "-o")
ylim(1e-10, 1)
xlabel("$k$")
ylabel("$|\\lambda_1 - \\beta_k|$")
title("Convergence of power iteration");
```

The asymptotic trend seems to be a straight line, consistent with linear convergence. To estimate the convergence rate, we look at the ratio of two consecutive errors in the linear part of the convergence curve. The ratio of the first two eigenvalues should match the observed rate.

```{code-cell}
print(f"theory: {ev[1] / ev[0]:.5f}")
print(f"observed: {err[40] / err[39]:.5f}")
```

Note that the error is supposed to change sign on each iteration. The effect of these alternating signs is that estimates oscillate around the exact value.

```{code-cell}
print(beta[26:30])
```

In practical situations, we don't know the exact eigenvalue that the algorithm is supposed to find. In that case we would base errors on the final $\beta$ that was found, as in the following plot.

```{code-cell}
err = beta[-1] - beta
semilogy(arange(60), abs(err), "-o")
ylim(1e-10, 1), xlabel("$k$")
ylabel("$|\\lambda_1 - \\beta_k|$")
title("Convergence of power iteration");
```

The results are very similar until the last few iterations, when the limited accuracy of the reference value begins to show. That is, while it is a good estimate of $\lambda_1$, it is less good as an estimate of the error in nearby estimates.

``````

### 8.3 @section-krylov-inviter

(demo-inviter-conv-python)=
``````{dropdown} Convergence of inverse iteration
We set up a $5\times 5$ triangular matrix with prescribed eigenvalues on its diagonal.

```{code-cell}
ev = array([1, -0.75, 0.6, -0.4, 0])
A = triu(ones([5, 5]), 1) + diag(ev)    # triangular matrix, eigs on diagonal
```

We run inverse iteration with the shift $s=0.7$. Convergence should be to the eigenvalue closest to the shift, which we know to be $0.6$ here.

```{code-cell}
beta, x = FNC.inviter(A, 0.7, 30)
print(beta)
```

As expected, the eigenvalue that was found is the one closest to 0.7. The convergence is again linear.

```{code-cell}
err = beta[-1] - beta    # last estimate is our best
semilogy(arange(30), abs(err), "-o")
ylim(1e-16, 1)
xlabel("$k$"),  ylabel("$|\\lambda_3 - \\beta_k|$")
title("Convergence of inverse iteration")
```

```{index} ! Python; argsort
```

::::{grid} 1 1 2 2
Let's reorder the eigenvalues to enforce {eq}`shiftorder`.
:::{card}
The `argsort` function returns the index permutation needed to sort the given vector, rather than the sorted vector itself.
::::

```{code-cell}
ev = ev[argsort(abs(ev - 0.7))]
print(ev)
```

Now it is easy to compare the theoretical and observed linear convergence rates.

```{code-cell}
print(f"theory: {(ev[0] - 0.7) / (ev[1] - 0.7):.5f}")
print(f"observed: {err[21] / err[20]:.5f}")
```
``````

(demo-inviter-accel-python)=
``````{dropdown} Dynamic shift strategy
```{code-cell}
ev = array([1, -0.75, 0.6, -0.4, 0])
A = triu(ones([5, 5]), 1) + diag(ev)    # triangular matrix, eigs on diagonal
```

We begin with a shift $s=0.7$, which is closest to the eigenvalue 0.6.

```{code-cell}
from numpy.linalg import solve
s = 0.7
x = ones(5)
y = solve(A - s * eye(5), x)
beta = x[0] / y[0] + s
print(f"latest estimate: {beta:.8f}")
```

Note that the result is not yet any closer to the targeted 0.6. But we proceed (without being too picky about normalization here).

```{code-cell}
s = beta
x = y / y[0]
y = solve(A - s * eye(5), x)
beta = x[0] / y[0] + s
print(f"latest estimate: {beta:.8f}")
```

Still not much apparent progress. However, in just a few more iterations the results are dramatically better.

```{code-cell}
for k in range(4):
    s = beta
    x = y / y[0]
    y = solve(A - s * eye(5), x)
    beta = x[0] / y[0] + s
    print(f"latest estimate: {beta:.8f}")
```
``````

### 8.4 @section-krylov-subspace

(demo-subspace-unstable-python)=
``````{dropdown} Conditioning of the Krylov matrix
First we define a triangular matrix with known eigenvalues, and a random vector $b$.

```{code-cell}
λ = @. 10 + (1:100)
A = triu(rand(100, 100), 1) + diagm(λ)
b = rand(100);
```

Next we build up the first ten Krylov matrices iteratively, using renormalization after each matrix-vector multiplication.

```{code-cell}
Km = [b zeros(100, 29)]
for m in 1:29
    v = A * Km[:, m]
    Km[:, m+1] = v / norm(v)
end
```

Now we solve least-squares problems for Krylov matrices of increasing dimension, recording the residual in each case.

```{code-cell}
resid = zeros(30)
for m in 1:30
    z = (A * Km[:, 1:m]) \ b
    x = Km[:, 1:m] * z
    resid[m] = norm(b - A * x)
end
```

The linear system approximations show smooth linear convergence at first, but the convergence stagnates after only a few digits have been found.

```{code-cell}
plot(0:29, resid, m=:o,
    xaxis=(L"m"), yaxis=(:log10, L"\| b-Ax_m \|"),
    title="Residual for linear systems", leg=:none)
```
``````

(demo-subspace-arnoldi-python)=
``````{dropdown} Arnoldi iteration
We illustrate a few steps of the Arnoldi iteration for a small matrix.

```{code-cell}
A = rand(1.0:9.0, 6, 6)
```

The seed vector we choose here determines the first member of the orthonormal basis.

```{code-cell}
u = randn(6)
Q = u / norm(u);
```

Multiplication by $\mathbf{A}$ gives us a new vector in $\mathcal{K}_2$.

```{code-cell}
Aq = A * Q[:, 1];
```

We subtract off its projection in the previous direction. The remainder is rescaled to give us the next orthonormal column.

```{code-cell}
v = Aq - dot(Q[:, 1], Aq) * Q[:, 1]
Q = [Q v / norm(v)];
```

On the next pass, we have to subtract off the projections in two previous directions.

```{code-cell}
Aq = A * Q[:, 2]
v = Aq - dot(Q[:, 1], Aq) * Q[:, 1] - dot(Q[:, 2], Aq) * Q[:, 2]
Q = [Q v / norm(v)];
```

At every step, $\mathbf{Q}_m$ is an ONC matrix.

```{code-cell}
@show opnorm(Q' * Q - I);
```

And $\mathbf{Q}_m$ spans the same space as the three-dimensional Krylov matrix.

```{code-cell}
K = [u A * u A * A * u];
@show rank([Q K]);
```
``````

### 8.5 @section-krylov-gmres

(demo-gmres-intro-python)=
``````{dropdown} GMRES
We define a triangular matrix with known eigenvalues and a random vector $\mathbf{b}$.

```{code-cell}
λ = @. 10 + (1:100)
A = triu(rand(100, 100), 1) + diagm(λ)
b = rand(100);
```

Instead of building the Krylov matrices, we use the Arnoldi iteration to generate equivalent orthonormal vectors.

```{code-cell}
Q, H = FNC.arnoldi(A, b, 60);
```

The Arnoldi bases are used to solve the least-squares problems defining the GMRES iterates.

```{code-cell}
resid = [norm(b); zeros(60)]
for m in 1:60
    s = [norm(b); zeros(m)]
    z = H[1:m+1, 1:m] \ s
    x = Q[:, 1:m] * z
    resid[m+1] = norm(b - A * x)
end
```

The approximations converge smoothly, practically all the way to machine epsilon.

```{code-cell}
plot(0:60, resid, m=:o,
    xaxis=(L"m"), yaxis=(:log10, "norm of mth residual"),
    title="Residual for GMRES", leg=:none)
```
``````

(demo-gmres-restart-python)=
``````{dropdown} Restarting GMRES
The following experiments are based on a matrix resulting from discretization of a partial differential equation.

```{index} Julia; keyword function arguments
```

```{code-cell}
A = FNC.poisson(50)
n = size(A, 1)
b = ones(n);
spy(A, color=:blues)
```

```{index} ! Julia; gmres
```

::::{grid} 1 1 2 2

:::{grid-item}


We compare unrestarted GMRES with three different thresholds for restarting. Here we are using `gmres` from the `IterativeSolvers` package, since our simple implementation does not offer restarting.


:::
:::{card}


The syntax `f(x;foo)` is shorthand for `f(x,foo=foo)`.

:::
::::

```{code-cell}
reltol = 1e-12;
plt = plot(title="Convergence of restarted GMRES", leg=:bottomleft,
    xaxis=(L"m"), yaxis=(:log10, "residual norm", [1e-8, 100]))

for restart in [n, 20, 40, 60]
    x, hist = IterativeSolvers.gmres(A, b; restart, reltol,
        maxiter=100, log=true)
    plot!(hist[:resnorm], label="restart = $restart")
end

plt
```

The "pure" GMRES curve is the lowest one. All of the other curves agree with it until the first restart. Decreasing the restart value makes the convergence per iteration generally worse, but the time required per iteration smaller as well.

``````
### 8.6 @section-krylov-minrescg

(demo-minrescg-indefinite-python)=
``````{dropdown} MINRES
The following matrix is indefinite.

```{code-cell}
A = FNC.poisson(10) - 20I
λ = eigvals(Matrix(A))
isneg = @. λ < 0
@show sum(isneg), sum(.!isneg);
```

We can compute the relevant quantities from {numref}`Theorem {number} <theorem-minrescg-indefinite>`.

```{code-cell}
mn, mx = extrema(-λ[isneg])
κ₋ = mx / mn
mn, mx = extrema(λ[.!isneg])
κ₊ = mx / mn
ρ = (sqrt(κ₋ * κ₊) - 1) / (sqrt(κ₋ * κ₊) + 1)
```

Because the iteration number $m$ is halved in {eq}`minres-conv`, the rate constant of linear convergence is the square root of this number, which makes it even closer to 1.

Now we apply MINRES to a linear system with this matrix, and compare the observed convergence to the upper bound from the theorem.

```{index} ! Julia; minres
```

```{code-cell}
b = rand(100)
x, hist = minres(A, b, reltol=1e-10, maxiter=51, log=true);

relres = hist[:resnorm] / norm(b)
m = 0:length(relres)-1
plot(m, relres, label="observed", leg=:left,
    xaxis=L"m", yaxis=(:log10, "relative residual"),
    title=("Convergence of MINRES"))
plot!(m, ρ .^ (m / 2), l=:dash, label="upper bound")
```

The upper bound turns out to be pessimistic here, especially in the later iterations. However, you can see a slow linear phase in the convergence that tracks the bound closely.
``````

(demo-minrescg-converge-python)=
``````{dropdown} Convergence of MINRES and CG
We will compare MINRES and CG on some quasi-random SPD problems.  The first matrix has a condition number of 100.

```{code-cell}
n = 5000
density = 0.001
A = FNC.sprandsym(n, density, 1 / 100)
x = (1:n) / n
b = A * x;
```

```{index} ! Julia; cg
```

Now we apply both methods and compare the convergence of the system residuals, using implementations imported from `IterativeSolvers`.

```{code-cell}
plt = plot(title="Convergence of MINRES and CG",
    xaxis=("Krylov dimension"), yaxis=(:log10, "relative residual norm"))
for method in [minres, cg]
    x̃, history = method(A, b, reltol=1e-6, maxiter=1000, log=true)
    relres = history[:resnorm] / norm(b)
    plot!(0:length(relres)-1, relres, label="$method")
    err = round(norm(x̃ - x) / norm(x), sigdigits=4)
    println("$method error: $err")
end
plt
```

There is little difference between the two methods here. Next, we increase the condition number of the matrix by a factor of 25. The rule of thumb predicts that the number of iterations required should increase by a factor of about 5.

```{code-cell}
A = FNC.sprandsym(n, density, 1 / 2500)
b = A * x;
```

```{code-cell}
:tags: [hide-input]

plt = plot(title="Convergence of MINRES and CG",
    xaxis=("Krylov dimension"), yaxis=(:log10, "relative residual norm"))
for method in [minres, cg]
    x̃, history = method(A, b, reltol=1e-6, maxiter=1000, log=true)
    relres = history[:resnorm] / norm(b)
    plot!(0:length(relres)-1, relres, label="$method")
    err = round(norm(x̃ - x) / norm(x), sigdigits=4)
    println("$method error: $err")
end
plt
```

Both methods have an early superlinear phase that allow them to finish slightly sooner than the factor of 5 predicted: {numref}`Theorem {number} <theorem-minrescg-converge>` is an upper bound, not necessarily an approximation. Both methods ultimately achieve the same reduction in the residual; MINRES stops earlier, but with a slightly larger error.

``````

### 8.7 @section-krylov-matrixfree

(demo-matrixfree-blur-python)=
``````{dropdown} Blurring an image
We use a readily available test image.

```{code-cell}
img = testimage("mandrill")
m, n = size(img)
X = @. Float64(Gray(img))
plot(Gray.(X), title="Original image", aspect_ratio=1)
```

We define the one-dimensional tridiagonal blurring matrices.

```{code-cell}
function blurmatrix(d)
    v1 = fill(0.25, d - 1)
    return spdiagm(0 => fill(0.5, d), 1 => v1, -1 => v1)
end
B, C = blurmatrix(m), blurmatrix(n);
```

Finally, we show the results of using $k=12$ repetitions of the blur in each direction.

```{code-cell}
blur = X -> B^12 * X * C^12;
Z = blur(X)
plot(Gray.(Z), title="Blurred image")
```
``````

(demo-matrixfree-deblur-python)=
``````{dropdown} Deblurring an image
We repeat the earlier process to blur an original image $\mathbf{X}$ to get $\mathbf{Z}$.

```{code-cell}
:tags: [hide-input]

img = testimage("lighthouse")
m, n = size(img)
X = @. Float64(Gray(img))

B = spdiagm(0 => fill(0.5, m),
    1 => fill(0.25, m - 1), -1 => fill(0.25, m - 1))
C = spdiagm(0 => fill(0.5, n),
    1 => fill(0.25, n - 1), -1 => fill(0.25, n - 1))
blur = X -> B^12 * X * C^12
Z = blur(X)
plot(Gray.(Z), title="Blurred image")
```

Now we imagine that $\mathbf{X}$ is unknown and that we want to recover it from $\mathbf{Z}$. We first need functions that translate between vector and matrix representations.

```{code-cell}
# vec (built-in) converts matrix to vector
unvec = z -> reshape(z, m, n);  # convert vector to matrix
```

```{index} ! Julia; LinearMap
```

Now we declare the three-step blur transformation as a `LinearMap`, supplying also the size of the vector form of an image.

```{code-cell}
T = LinearMap(x -> vec(blur(unvec(x))), m * n);
```

::::{grid} 1 1 2 2

:::{grid-item}


The blurring operators are symmetric, so we apply `minres` to the composite blurring transformation `T`.


:::
:::{card}


The function `clamp01` in `Images` restricts values to be in the interval $[0,1]$.

:::
::::

```{code-cell}
y = minres(T, vec(Z), maxiter=50, reltol=1e-5);
Y = unvec(clamp01.(y))

plot(Gray.(X), layout=2, title="Original")
plot!(Gray.(Y), subplot=2, title="Deblurred")
```
``````

### 8.8 @section-krylov-precond

(demo-precond-diagonal-python)=
``````{dropdown} Diagonal preconditioning
Here is an SPD matrix that arises from solving partial differential equations.

```{code-cell}
A = matrixdepot("wathen", 60)
n = size(A, 1)
@show n, nnz(A);
```

```{index} ! Julia; DiagonalPreconditioner
```

There is an easy way to use the diagonal elements of $\mathbf{A}$, or any other vector, as a diagonal preconditioner.

```{code-cell}
b = ones(n)
M = DiagonalPreconditioner(diag(A));
```

We now compare CG with and without the preconditioner.

```{code-cell}
:tags: [hide-input]

plain(b) = cg(A, b, maxiter=200, reltol=1e-4, log=true)
time_plain = @elapsed x, hist1 = plain(b)
prec(b) = cg(A, b, Pl=M, maxiter=200, reltol=1e-4, log=true)
time_prec = @elapsed x, hist2 = prec(b)
@show time_plain, time_prec

rr = hist1[:resnorm]
plot(0:length(rr)-1, rr / rr[1], yscale=:log10, label="plain")
rr = hist2[:resnorm]
plot!(0:length(rr)-1, rr / rr[1], yscale=:log10, label="preconditioned")
title!("Diagonal preconditioning in CG")
```

The diagonal preconditioner cut down substantially on the number of iterations. The effect on the total time is less dramatic, but this is not a large version of the problem.

``````

(demo-precond-gmres-python)=
``````{dropdown} Incomplete LU preconditioning
Here is a nonsymmetric matrix arising from a probabilistic model in computational chemistry.

```{code-cell}
A = sparse(matrixdepot("Watson/chem_master1"))
n = size(A, 1)
@show n, nnz(A), issymmetric(A)
```

Without a preconditioner, GMRES makes essentially no progress after 100 iterations.

```{code-cell}
b = rand(40000)
const GMRES = IterativeSolvers.gmres
x, history = GMRES(A, b, maxiter=100, reltol=1e-5, log=true)
resnorm = history[:resnorm]
@show resnorm[end] / resnorm[1];
```

```{index} ! Julia; ilu
```

The following version of incomplete LU factorization drops all sufficiently small values (i.e., replaces them with zeros). This keeps the number of nonzeros in the factors under control.

```{code-cell}
iLU = ilu(A, τ=0.25)
@show nnz(iLU) / nnz(A);
```

The result is almost 10 times as dense as $\mathbf{A}$ and yet still not a true factorization of it. However, it's close enough for an approximate inverse in a preconditioner. The actual preconditioning matrix is $\mathbf{M}=\mathbf{L}\mathbf{U}$, but we just supply the factorization to `gmres`.

```{code-cell}
_, history = GMRES(A, b, Pl=iLU, maxiter=100, reltol=1e-5, log=true)
history
```

The $\tau$ parameter in `ilu` balances the accuracy of the iLU factorization with the time needed to compute it and invert it. As $\tau\to 0$, more of the elements are kept, making the preconditioner more effective but slower per iteration.

```{code-cell}
:tags: [hide-input]

plt = plot(0:40, resnorm[1:41] / resnorm[1], label="no preconditioning",
    xaxis=("iteration number"), yaxis=(:log10, "residual norm"),
    leg=:bottomright, title="Incomplete LU preconditioning")
for τ in [2, 1, 0.25, 0.1]
    t = @elapsed iLU = ilu(A; τ)
    t += @elapsed _, history = GMRES(A, b, Pl=iLU, maxiter=100,
        reltol=1e-5, log=true)
    resnorm = history[:resnorm]
    label = "τ = $τ, time = $(round(t,digits=3))"
    plot!(0:length(resnorm)-1, resnorm / resnorm[1]; label)
end
plt
```

In any given problem, it's impossible to know in advance where the right balance lies between fidelity and speed for the preconditioner.

---
numbering:
  enumerator: 8.5.%s
kernelspec:
  display_name: Python 3
  language: python
  name: python3
---
```{code-cell}
:tags: [remove-cell]
from numpy import *
from scipy import linalg
from scipy.linalg import norm
from matplotlib.pyplot import *
from prettytable import PrettyTable
from timeit import default_timer as timer
import sys
sys.path.append('fncbook/')
import fncbook as FNC

# This (optional) block is for improving the display of plots.
# from IPython.display import set_matplotlib_formats
# set_matplotlib_formats("svg","pdf")
# %config InlineBackend.figure_format = 'svg'
rcParams["figure.figsize"] = [7, 4]
rcParams["lines.linewidth"] = 2
rcParams["lines.markersize"] = 4
rcParams['animation.html'] = "jshtml"  # or try "html5"
```

(section-krylov-gmres)=

# GMRES

The most important use of the Arnoldi iteration is to solve the square linear system $\mathbf{A}\mathbf{x}=\mathbf{b}$, resulting in a well-known algorithm called GMRES.[^gmres]

In @demo-subspace-unstable, we attempted to replace the linear system $\mathbf{A}\mathbf{x}=\mathbf{b}$ by the lower-dimensional approximation

```{math}
\min_{\mathbf{x}\in \mathcal{K}_m} \|  \mathbf{A}\mathbf{x}-\mathbf{b}  \| = \min_{\mathbf{z}\in\mathbb{C}^m} \|   \mathbf{A}\mathbf{K}_m\mathbf{z}-\mathbf{b}  \|,
```

where $\mathbf{K}_m$ is the Krylov matrix generated using $\mathbf{A}$ and the seed vector $\mathbf{b}$. This method was unstable due to the poor conditioning of $\mathbf{K}_m$, which is a numerically poor basis for $\mathcal{K}_m$. Instead, we can use the orthonormal basis $\mathbf{Q}_m$ generated by the Arnoldi iteration.

(section-gmres-derivation)=

## Derivation

If we set $\mathbf{x}=\mathbf{Q}_m\mathbf{z}$ in the residual $\mathbf{b} - \mathbf{A}\mathbf{x}$, we obtain a way to minimize the norm of the residual over $\mathcal{K}_m$:

```{math}
:label: gmresproblem
\min_{\mathbf{z}\in\mathbb{C}^m}\, \bigl\| \mathbf{A} \mathbf{Q}_m \mathbf{z} - \mathbf{b}  \bigr\|.
```

From the fundamental Arnoldi identity {eq}`arnoldimat`, this is equivalent to

```{math}
:label: gmresproblem1
\min_{\mathbf{z}\in\mathbb{C}^m}\, \bigl\| \mathbf{Q}_{m+1} \mathbf{H}_m\mathbf{z}-\mathbf{b} \bigr\|.
```

Note that $\mathbf{q}_1$ is a unit multiple of $\mathbf{b}$, so $\mathbf{b} = \|\mathbf{b}\| \mathbf{Q}_{m+1}\mathbf{e}_1$. Thus, {eq}`gmresproblem1` becomes

```{math}
:label: gmresproblem2
\min_{\mathbf{z}\in\mathbb{C}^m}\, \bigl\| \mathbf{Q}_{m+1} (\mathbf{H}_m\mathbf{z}-\|\mathbf{b}\|\mathbf{e}_1) \bigr\|.
```

The least-squares problems {eq}`gmresproblem`,  {eq}`gmresproblem1`, and {eq}`gmresproblem2` are all $n\times m$. But observe that for any $\mathbf{w}\in\mathbb{C}^{m+1}$,

```{math}
  \|\mathbf{Q}_{m+1}\mathbf{w}\|^2 = \mathbf{w}^*\mathbf{Q}_{m+1}^*\mathbf{Q}_{m+1}\mathbf{w} = \mathbf{w}^*\mathbf{w} = \|\mathbf{w}\|^2.
```

The first norm in that equation is on $\mathbb{C}^n$, while the last is on the much smaller space $\mathbb{C}^{m+1}$. Hence, the least-squares problem {eq}`gmresproblem2` is equivalent to

```{math}
:label: gmresproblemsmall
  \min_{\mathbf{z}\in\mathbb{C}^m}\, \bigl\| \mathbf{H}_m\mathbf{z}-\|\mathbf{b}\|\, \mathbf{e}_1 \bigr\|,
```

which is of size $(m+1)\times m$. We call the solution of this minimization $\mathbf{z}_m$, and then $\mathbf{x}_m=\mathbf{Q}_m \mathbf{z}_m$ is the $m$th approximation to the solution of $\mathbf{A}\mathbf{x}=\mathbf{b}$.

```{index} ! GMRES
```

::::{prf:algorithm} GMRES
Given $n\times n$ matrix $\mathbf{A}$ and $n$-vector $\mathbf{b}$:

For $m=1,2,\ldots$, let $\mathbf{x}_m=\mathbf{Q}_m \mathbf{z}_m$, where $\mathbf{z}_m$ solves the linear least-squares problem {eq}`gmresproblemsmall`, and $\mathbf{Q}_m,\mathbf{H}_m$ arise from the Arnoldi iteration.

The sequence $\mathbf{x}_m$ converges to the solution of $\mathbf{A}\mathbf{x}=\mathbf{b}$.[^breakdown]
::::

In exact arithmetic, GMRES should get the exact solution when $m=n$, but the goal is to reduce the residual enough to stop at some $m \ll n$.

[^gmres]: GMRES stands for Generalized Minimum RESidual. We will encounter its precursor MINRES in {numref}`section-krylov-minrescg`.

[^breakdown]: This statement is not strictly correct for rare special cases of *breakdown* where the rank of $\mathcal{K}_m$ is less than $m$. In that situation, some additional steps must be taken that we do not discuss here.

A basic implementation of GMRES is given in {numref}`Function {number} <function-gmres>`.

``````{prf:algorithm} gmres
:label: function-gmres

```{literalinclude} chapter08.py
:filename: gmres.py
:start-at: def gmres
:end-at: return x, residual
:language: python
:linenos: true
```
``````

## Convergence

In @demo-subspace-unstable, we tried to implement the GMRES idea using the Krylov matrix. After some initial reduction in the norm of the residual, improvement stopped due to the poor conditioning of that matrix. We return to the linear system in that example now to show that a stable implementation based on the Arnoldi iteration continues to improve the residual nearly to machine precision.

::::{prf:example} GMRES
:label: demo-gmres-intro

We define a triangular matrix with known eigenvalues and a random vector $\mathbf{b}$.

```{code-cell}
ev = 10 + arange(1, 101)
A = triu(random.rand(100, 100), 1) + diag(ev)
b = random.rand(100)
```

Instead of building the Krylov matrices, we use the Arnoldi iteration to generate equivalent orthonormal vectors.

```{code-cell}
Q, H = FNC.arnoldi(A, b, 60)
print(H[:5, :5])
```

The Arnoldi bases are used to solve the least-squares problems defining the GMRES iterates.

```{code-cell}
from numpy.linalg import lstsq
resid = zeros(61)
resid[0] = norm(b)
for m in range(1, 61):
    s = hstack([norm(b), zeros(m)])
    z = lstsq(H[: m + 1, :m], s, rcond=None)[0]
    x = Q[:, :m] @ z
    resid[m] = norm(b - A @ x)
```

The approximations converge smoothly, practically all the way to machine epsilon.

```{code-cell}
semilogy(range(61), resid, "-o")
xlabel("$m$"),  ylabel("$\| b-Ax_m \|$")
title("Residual for GMRES");
```

::::

Thanks to @theorem-subspace-krylovmult, minimization of $\|\mathbf{b}-\mathbf{A}\mathbf{x}\|$ over $\mathcal{K}_{m+1}$ includes minimization over the subset $\mathcal{K}_m$. Hence:

:::{prf:theorem} GMRES monotonicity
For the approximations $\mathbf{x}_m$ produced by GMRES, the norm of the residual $\mathbf{r}_m = \mathbf{b} - \mathbf{A}\mathbf{x}_m$ cannot increase as the iteration proceeds.
:::

```{index} convergence rate; linear
```

Unfortunately, making other conclusive statements about the convergence of GMRES is not easy. @demo-gmres-intro shows the cleanest behavior: essentially, linear convergence down to the range of machine epsilon. But it is possible for the convergence to go through phases of sublinear and superlinear convergence as well. There is a strong dependence on the eigenvalues of the matrix, a fact we address with more precision and detail in the next section.

```{index} ! GMRES; restarting
```

(section-gmres-restart)=

## Restarting

One of the practical challenges in GMRES is that as the dimension of the Krylov subspace grows, the number of new entries to be found in $\mathbf{H}_m$ and the total number of basis vectors grow, too. Consequently, both the work and the storage requirements are quadratic in $m$, which can become intolerable in some applications. For this reason, GMRES is often used with **restarting**.

Suppose $\hat{\mathbf{x}}$ is an approximate solution of $\mathbf{A}\mathbf{x}=\mathbf{b}$. Then, if we set $\mathbf{x}=\mathbf{u}+\hat{\mathbf{x}}$, we have $\mathbf{A}(\mathbf{u}+\hat{\mathbf{x}}) = \mathbf{b}$, or $\mathbf{A}\mathbf{u} = \mathbf{b} - \mathbf{A}\hat{\mathbf{x}}$. The conclusion is that if we get an approximate solution and compute its residual $\mathbf{r}=\mathbf{b} - \mathbf{A}\hat{\mathbf{x}}$, then we need only to solve $\mathbf{A}\mathbf{u} = \mathbf{r}$ in order to get a correction to $\hat{\mathbf{x}}$.[^relativerestart]

[^relativerestart]: The new problem needs to be solved for accuracy relative to $\|\mathbf{b}\|$, *not* relative to $\|\mathbf{r}\|$.

Restarting guarantees a fixed upper bound on the per-iteration cost of GMRES. However, this benefit comes at a price. Even though restarting preserves progress made in previous iterations, the Krylov space information is discarded and the residual minimization process starts again over low-dimensional spaces. That can significantly retard or even stagnate the convergence.

::::{prf:example} Restarting GMRES
:label: demo-gmres-restart

The following experiments are based on a matrix resulting from discretization of a partial differential equation.

```{code-cell}
d = 50;  n = d**2
A = FNC.poisson2d(d)
b = ones(n)
spy(A);
```

```{index} ! Python; gmres
```

We compare unrestarted GMRES with three different thresholds for restarting. Here we are using `gmres` from `scipy.sparse.linalg`, since our simple implementation does not offer restarting. We're also using a trick to accumulate the vector of residual norms as it runs.

```{code-cell}
from scipy.sparse.linalg import gmres
ctr = lambda rvec: resid.append(norm(rvec))
resid = [1.]
x, flag = gmres(A, b, restart=None, rtol=1e-8, atol=1e-14, maxiter=120, callback=ctr)
semilogy(resid); 
xlabel("$m$"), ylabel("residual norm")
title(("Convergence of unrestarted GMRES"));
```

```{code-cell}
maxit = 120
rtol = 1e-8
restarts = [maxit, 20, 40, 60]
hist = lambda rvec: resid.append(norm(rvec))
for r in restarts:
    resid = [1.]
    x, flag = gmres(A, b, restart=r, rtol=rtol, atol=1e-14, maxiter=maxit, callback=hist)
    semilogy(resid)

ylim(1e-8, 2)
legend(["none", "20", "40", "60"])
title(("Convergence of restarted GMRES"));
```

The "pure" GMRES curve is the lowest one. All of the other curves agree with it until the first restart. Decreasing the restart value makes the convergence per iteration generally worse, but the time required per iteration smaller as well.


::::

Restarting creates a tradeoff between the number of iterations and the speed per iteration. It's essentially impossible in general to predict the ideal restart location in any given problem, so one goes by experience and hopes for the best.

There are other ways to avoid the growth in computational effort as the GMRES/Arnoldi iteration proceeds. Three of the more popular variations are abbreviated CGS, BiCGSTAB, and QMR. We do not describe them in this book.

## Exercises

``````{exercise}
:label: problem-gmres-permutation
✍ (See also @problem-subspace-permute.) Consider the linear system with

$$
\mathbf{A}=\displaystyle 
\begin{bmatrix}
0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \\ 1 & 0 & 0 & 0
\end{bmatrix}, \qquad \mathbf{b}=\mathbf{e}_1.
$$

**(a)** Find the exact solution by inspection.

**(b)** Find the GMRES approximate solutions $\mathbf{x}_m$ for $m=1,2,3,4$. (You should not try to do the Arnoldi iteration by hand. Instead, apply the result in @gmresdef to get a tractable least-squares problem.)
``````

``````{exercise}
:label: problem-gmres-polynomial
✍ (Continuation of @problem-subspace-matrixpolykrylov.) Show that if $\mathbf{x}_m\in\mathcal{K}_m$, then the residual $\mathbf{b}-\mathbf{A}\mathbf{x}_m$ is equal to $q(\mathbf{A})\mathbf{b}$, where $q$ is a polynomial of degree at most $m$ and $q(0)=1$. (This fact is a key one for many convergence results.) 
``````

``````{exercise}
:label: problem-gmres-finite
✍ Explain why GMRES, in exact arithmetic, converges to the true solution in $n$ iterations for an $n\times n$ matrix if $\operatorname{rank}(\mathbf{K}_n)=n$. (Hint: Consider how the algorithm is defined from first principles.) 
``````

``````{exercise}
:label: problem-gmres-tridiagonal
⌨ Let $\mathbf{A}$ be the $n\times n$ tridiagonal matrix

$$
\begin{bmatrix}
-4 & 1      &        &        &   \\
1  & -4     & 1      &        &   \\
& \ddots & \ddots & \ddots &   \\
&        & 1      & -4     & 1 \\
&        &        & 1      & -4 
\end{bmatrix}
$$

and let the $n$-vector $\mathbf{b}$ have elements $b_i=i/n$. For $n=8,16,32,64$, run {numref}`Function {number} <function-gmres>` for $m=n/2$ iterations. On one semi-log graph, plot $\|\mathbf{r}_k\|/\|\mathbf{b}\|$ for all the cases. How does the convergence rate of GMRES seem to depend on $n$?  
``````

% must stay as #5

``````{exercise}
:label: problem-gmres-surround
⌨  In this exercise you will see the strong effect the eigenvalues of the matrix may have on GMRES convergence. Let 

$$
\mathbf{B}=
\begin{bmatrix}
1 & & & \\
& 2 & & \\
& & \ddots & \\
& & & 100
\end{bmatrix},
$$ 

let $\mathbf{I}$ be a $100\times 100$ identity, and let $\mathbf{Z}$ be a $100\times 100$ matrix of zeros. Also let $\mathbf{b}$ be a $200\times 1$ vector of ones. You will use GMRES with restarts, as in @demo-gmres-restart (i.e., not the book's version of `gmres`).

**(a)** Let $\mathbf{A} = \begin{bmatrix} \mathbf{B} & \mathbf{I} \\ \mathbf{Z} & \mathbf{B} \end{bmatrix}.$ What are its eigenvalues (no computer required here)? Apply `gmres` with tolerance $10^{-10}$ for 100 iterations without restarts, and plot the residual convergence. 

**(b)** Repeat part (a) with restarts every 20 iterations. 

**(c)** Now let $\mathbf{A} = \begin{bmatrix} \mathbf{B} & \mathbf{I} \\ \mathbf{Z} & -\mathbf{B} \end{bmatrix}.$ What are its eigenvalues? Repeat part (a). Which matrix is more difficult for GMRES? (Note: Even though this matrix is triangular, GMRES has no way of exploiting that fact.)
``````

``````{exercise}
:label: problem-gmres-lumpmembrane
⌨ (Continuation of @problem-inviter-lumpmembrane.) We again consider the $n^2\times n^2$ sparse matrix defined by `FNC.poisson(n)`. The solution of $\mathbf{A}\mathbf{x}=\mathbf{b}$ may be interpreted as the deflection of a lumped membrane in response to a load represented by $\mathbf{b}$.

**(a)** For $n=10,15,20,25$, let $\mathbf{b}$ be the vector of $n^2$ ones and apply {numref}`Function {number} <function-gmres>` for 50 iterations. On one semi-log graph, plot the four convergence curves $\|\mathbf{r}_m\|/\|\mathbf{b}\|$.

**(b)** For the case $n=25$ make a surface plot of `x` after reshaping it to a 25×25 matrix. It should look physically plausible (though upside-down for a weighted membrane).
``````
